{% extends "base.html" %}

{% block title %}Timing Practice - Bass Practice{% endblock %}

{% block extra_css %}
<style>
    .game-card {
        cursor: pointer;
        transition: all 0.3s ease;
        border: 2px solid transparent;
    }
    
    .game-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    }
    
    .game-card.selected {
        border-color: var(--primary-color);
    }
    
    .game-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
    }
    
    /* Game UI */
    #game-container {
        display: none;
    }
    
    .beat-track {
        position: relative;
        height: 120px;
        background: linear-gradient(90deg, var(--darker-bg) 0%, var(--card-bg) 50%, var(--darker-bg) 100%);
        border-radius: 12px;
        overflow: hidden;
        margin: 2rem 0;
    }
    
    .beat-line {
        position: absolute;
        left: 50%;
        top: 0;
        bottom: 0;
        width: 4px;
        background: var(--primary-color);
        box-shadow: 0 0 20px var(--primary-color);
        z-index: 10;
    }
    
    .beat-note {
        position: absolute;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--accent-color);
        top: 50%;
        transform: translateY(-50%);
        transition: left 0.016s linear;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
    
    .beat-note.hit-perfect {
        background: #22c55e;
        animation: hit-flash 0.3s ease;
    }
    
    .beat-note.hit-good {
        background: #3b82f6;
        animation: hit-flash 0.3s ease;
    }
    
    .beat-note.hit-early,
    .beat-note.hit-late {
        background: #f59e0b;
        animation: hit-flash 0.3s ease;
    }
    
    .beat-note.missed {
        background: #ef4444;
        opacity: 0.5;
    }
    
    @keyframes hit-flash {
        0% { transform: translateY(-50%) scale(1); }
        50% { transform: translateY(-50%) scale(1.3); }
        100% { transform: translateY(-50%) scale(1); }
    }
    
    /* Score display */
    .score-display {
        font-size: 4rem;
        font-weight: 700;
        font-family: 'Consolas', monospace;
        color: var(--primary-color);
        text-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
    }
    
    .streak-display {
        font-size: 1.5rem;
        color: var(--accent-color);
    }
    
    .streak-display.on-fire {
        animation: fire-pulse 0.5s ease infinite;
    }
    
    @keyframes fire-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    /* Hit feedback */
    .hit-feedback {
        font-size: 2rem;
        font-weight: 700;
        text-transform: uppercase;
        min-height: 3rem;
    }
    
    .hit-feedback.perfect { color: #22c55e; }
    .hit-feedback.good { color: #3b82f6; }
    .hit-feedback.early { color: #f59e0b; }
    .hit-feedback.late { color: #f59e0b; }
    .hit-feedback.miss { color: #ef4444; }
    
    /* Audio input indicator */
    .audio-indicator {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #6c7086;
        transition: all 0.1s ease;
    }
    
    .audio-indicator.connected {
        background: #22c55e;
        box-shadow: 0 0 10px #22c55e;
    }
    
    .audio-indicator.active {
        background: #f59e0b;
        transform: scale(1.2);
        box-shadow: 0 0 15px #f59e0b;
    }
    
    /* Volume meter */
    .volume-meter {
        width: 100%;
        height: 8px;
        background: var(--darker-bg);
        border-radius: 4px;
        overflow: hidden;
    }
    
    .volume-meter-fill {
        height: 100%;
        background: linear-gradient(90deg, #22c55e 0%, #f59e0b 70%, #ef4444 100%);
        transition: width 0.05s ease;
        width: 0%;
    }
    
    /* Difficulty buttons */
    .difficulty-btn {
        padding: 0.5rem 1rem;
        border-radius: 8px;
        border: 2px solid var(--card-bg);
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .difficulty-btn:hover {
        border-color: var(--primary-color);
    }
    
    .difficulty-btn.selected {
        background: var(--primary-color);
        border-color: var(--primary-color);
    }
    
    /* Results modal */
    .result-stat {
        text-align: center;
        padding: 1rem;
    }
    
    .result-stat .value {
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--primary-color);
    }
    
    .result-stat .label {
        color: var(--text-secondary);
        font-size: 0.9rem;
    }
    
    .timing-bar {
        display: flex;
        height: 30px;
        border-radius: 8px;
        overflow: hidden;
        background: var(--darker-bg);
    }
    
    .timing-bar .segment {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 600;
    }
    
    .timing-bar .perfect { background: #22c55e; color: white; }
    .timing-bar .good { background: #3b82f6; color: white; }
    .timing-bar .early { background: #f59e0b; color: black; }
    .timing-bar .late { background: #fb923c; color: black; }
    .timing-bar .miss { background: #ef4444; color: white; }
    
    /* Countdown */
    .countdown {
        font-size: 8rem;
        font-weight: 700;
        color: var(--primary-color);
        text-shadow: 0 0 50px rgba(99, 102, 241, 0.5);
        animation: countdown-pulse 1s ease infinite;
    }
    
    @keyframes countdown-pulse {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.1); opacity: 0.8; }
    }
    
    /* Calibration styles */
    .calibration-beat {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        background: var(--card-bg);
        border: 4px solid var(--primary-color);
        margin: 2rem auto;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        font-weight: bold;
        transition: all 0.1s ease;
    }
    
    .calibration-beat.flash {
        background: var(--primary-color);
        transform: scale(1.2);
        box-shadow: 0 0 30px var(--primary-color);
    }
    
    .calibration-beat.hit {
        background: #22c55e;
        border-color: #22c55e;
        box-shadow: 0 0 30px #22c55e;
    }
    
    .calibration-dots-container {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin: 1rem 0;
    }
    
    .calibration-dot {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--card-bg);
        border: 2px solid var(--text-muted);
    }
    
    .calibration-dot.complete {
        background: #22c55e;
        border-color: #22c55e;
    }
    
    .calibration-dot.current {
        border-color: var(--primary-color);
        animation: pulse-border 1s ease infinite;
    }
    
    @keyframes pulse-border {
        0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.5); }
        50% { box-shadow: 0 0 0 8px rgba(99, 102, 241, 0); }
    }
    
    .offset-display {
        font-size: 3rem;
        font-weight: 700;
        font-family: 'Consolas', monospace;
    }
    
    .offset-display.positive { color: #f59e0b; }
    .offset-display.negative { color: #3b82f6; }
    .offset-display.neutral { color: #22c55e; }
</style>
{% endblock %}

{% block content %}
<div class="container py-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1><i class="bi bi-stopwatch"></i> Timing Practice</h1>
            <p class="text-secondary mb-0">Practice tight timing with your bass using audio input</p>
        </div>
        <div class="d-flex align-items-center gap-3">
            <div class="d-flex align-items-center gap-2">
                <span class="text-secondary">Audio:</span>
                <div class="audio-indicator" id="audio-status"></div>
                <span id="audio-status-text" class="text-muted small">Not connected</span>
            </div>
            <button class="btn btn-outline-primary" id="connect-audio-btn">
                <i class="bi bi-mic"></i> Connect Audio
            </button>
        </div>
    </div>
    
    <!-- Audio Setup Panel -->
    <div class="card mb-4" id="audio-setup-panel" style="display: none;">
        <div class="card-body">
            <h5 class="card-title"><i class="bi bi-sliders"></i> Audio Input Setup</h5>
            <div class="row align-items-center">
                <div class="col-md-3">
                    <label class="form-label">Select Audio Input</label>
                    <select class="form-select" id="audio-device-select">
                        <option value="">Loading devices...</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Input Level</label>
                    <div class="volume-meter">
                        <div class="volume-meter-fill" id="volume-meter-fill"></div>
                    </div>
                </div>
                <div class="col-md-2">
                    <label class="form-label">Threshold</label>
                    <input type="range" class="form-range" id="threshold-slider" min="0" max="100" value="30">
                </div>
                <div class="col-md-2">
                    <label class="form-label">Latency Offset</label>
                    <div class="d-flex align-items-center gap-2">
                        <span id="calibration-offset-display" class="badge bg-secondary">0ms</span>
                    </div>
                </div>
                <div class="col-md-2">
                    <label class="form-label">&nbsp;</label>
                    <button class="btn btn-outline-warning w-100" id="calibrate-btn">
                        <i class="bi bi-bullseye"></i> Calibrate
                    </button>
                </div>
            </div>
            <div class="row mt-2">
                <div class="col-12">
                    <small class="text-muted">
                        <i class="bi bi-info-circle"></i> 
                        Calibration compensates for audio interface latency. Click "Calibrate" and play along with the clicks.
                    </small>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Selection -->
    <div id="game-selection">
        <h3 class="mb-3">Choose Your Game</h3>
        <div class="row g-4 mb-4">
            {% for mode_id, mode in game_modes.items() %}
            <div class="col-md-4">
                <div class="card game-card h-100" data-mode="{{ mode_id }}">
                    <div class="card-body text-center">
                        <div class="game-icon" style="color: {{ mode.color }};">
                            <i class="bi bi-{{ mode.icon }}"></i>
                        </div>
                        <h4 class="card-title">{{ mode.name }}</h4>
                        <p class="card-text">{{ mode.description }}</p>
                        {% if high_scores.get(mode_id) %}
                        <div class="mt-3">
                            <span class="badge bg-warning text-dark">
                                <i class="bi bi-trophy"></i> High Score: {{ high_scores[mode_id].high_score }}
                            </span>
                        </div>
                        {% endif %}
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
        
        <!-- Game Settings -->
        <div class="card mb-4">
            <div class="card-body">
                <div class="row align-items-center">
                    <div class="col-md-4">
                        <label class="form-label">Difficulty</label>
                        <div class="btn-group d-flex" role="group">
                            {% for level, config in difficulty_levels.items() %}
                            <button type="button" class="difficulty-btn flex-fill {% if level == 1 %}selected{% endif %}" data-difficulty="{{ level }}">
                                {{ config.name }}
                            </button>
                            {% endfor %}
                        </div>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label">Tempo (BPM)</label>
                        <div class="input-group">
                            <input type="number" class="form-control" id="tempo-input" min="40" max="200" value="80">
                            <button class="btn btn-outline-secondary" type="button" id="random-tempo-btn" title="Random tempo">
                                <i class="bi bi-shuffle"></i>
                            </button>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label">Duration (bars)</label>
                        <select class="form-select" id="duration-select">
                            <option value="4">4 bars</option>
                            <option value="8" selected>8 bars</option>
                            <option value="16">16 bars</option>
                            <option value="32">32 bars (endurance)</option>
                        </select>
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                        <button class="btn btn-primary btn-lg w-100" id="start-game-btn" disabled>
                            <i class="bi bi-play-fill"></i> Start
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Stats Overview -->
        <div class="row g-4">
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{{ total_sessions }}</div>
                    <div class="stat-label">Total Sessions</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{{ total_notes }}</div>
                    <div class="stat-label">Notes Played</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{{ overall_accuracy }}%</div>
                    <div class="stat-label">Overall Accuracy</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{% if best_session %}{{ best_session.score }}{% else %}0{% endif %}</div>
                    <div class="stat-label">Best Score</div>
                </div>
            </div>
        </div>
        
        <!-- Recent Sessions -->
        {% if recent_sessions %}
        <div class="card mt-4">
            <div class="card-header">
                <h5 class="mb-0"><i class="bi bi-clock-history"></i> Recent Sessions</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-dark table-hover mb-0">
                        <thead>
                            <tr>
                                <th>Game</th>
                                <th>Tempo</th>
                                <th>Difficulty</th>
                                <th>Score</th>
                                <th>Accuracy</th>
                                <th>Perfect</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for session in recent_sessions %}
                            <tr>
                                <td>{{ game_modes[session.game_mode].name if session.game_mode in game_modes else session.game_mode }}</td>
                                <td>{{ session.tempo_bpm }} BPM</td>
                                <td>{{ difficulty_levels[session.difficulty].name if session.difficulty in difficulty_levels else session.difficulty }}</td>
                                <td><strong>{{ session.score }}</strong></td>
                                <td>{{ session.accuracy_percentage }}%</td>
                                <td>{{ session.perfect_percentage }}%</td>
                                <td>{{ session.created_at.strftime('%b %d, %H:%M') }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        {% endif %}
    </div>
    
    <!-- Game Container (Hidden until game starts) -->
    <div id="game-container">
        <!-- Countdown -->
        <div id="countdown-screen" class="text-center py-5" style="display: none;">
            <p class="text-secondary mb-3">
                <span id="countdown-tempo">80</span> BPM
                <span id="countdown-calibration" class="ms-3 badge bg-secondary">0ms offset</span>
            </p>
            <div class="countdown" id="countdown-number">4</div>
            <p class="text-muted mt-3">Listen for the clicks - game starts after the count-in!</p>
        </div>
        
        <!-- Game UI -->
        <div id="game-screen" style="display: none;">
            <div class="row mb-4">
                <div class="col-md-4 text-center">
                    <div class="score-display" id="current-score">0</div>
                    <div class="text-secondary">Score</div>
                </div>
                <div class="col-md-4 text-center">
                    <div class="hit-feedback" id="hit-feedback">&nbsp;</div>
                    <div id="timing-offset" class="text-muted"></div>
                </div>
                <div class="col-md-4 text-center">
                    <div class="streak-display" id="streak-display">
                        <i class="bi bi-fire"></i> <span id="current-streak">0</span>
                    </div>
                    <div class="text-secondary">Streak</div>
                </div>
            </div>
            
            <!-- Beat Track -->
            <div class="beat-track" id="beat-track">
                <div class="beat-line"></div>
                <!-- Notes will be added dynamically -->
            </div>
            
            <!-- Progress -->
            <div class="d-flex justify-content-between align-items-center mb-3">
                <span class="text-secondary">
                    <i class="bi bi-music-note"></i> <span id="notes-hit">0</span> / <span id="total-notes">0</span> notes
                </span>
                <span class="text-secondary">
                    <i class="bi bi-speedometer2"></i> <span id="current-tempo">80</span> BPM
                </span>
                <span class="text-secondary">
                    <i class="bi bi-clock"></i> <span id="time-remaining">0:00</span>
                </span>
            </div>
            
            <div class="progress mb-4" style="height: 8px;">
                <div class="progress-bar bg-primary" id="game-progress" style="width: 0%"></div>
            </div>
            
            <!-- Controls -->
            <div class="text-center">
                <button class="btn btn-outline-danger btn-lg" id="stop-game-btn">
                    <i class="bi bi-stop-fill"></i> Stop Game
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Calibration Modal -->
<div class="modal fade" id="calibration-modal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-bullseye"></i> Audio Calibration</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" id="calibration-close-btn"></button>
            </div>
            <div class="modal-body text-center">
                <!-- Calibration Instructions -->
                <div id="calibration-instructions">
                    <p class="lead">Let's calibrate your audio input</p>
                    <div class="alert alert-info text-start">
                        <i class="bi bi-lightbulb"></i>
                        <strong>How it works:</strong><br>
                        You'll hear a count-in (<em>3, 2, 1</em>) followed by a louder main click.<br>
                        Play a note on your bass <strong>exactly</strong> on the main click.<br>
                        This repeats 8 times to measure your audio latency.
                    </div>
                    <p class="text-secondary">
                        <i class="bi bi-volume-up"></i> Make sure your speakers/headphones are on<br>
                        <i class="bi bi-mic"></i> Make sure your bass is connected and the input level is good
                    </p>
                    <button class="btn btn-primary btn-lg" id="start-calibration-btn">
                        <i class="bi bi-play-fill"></i> Start Calibration
                    </button>
                </div>
                
                <!-- Calibration In Progress -->
                <div id="calibration-progress" style="display: none;">
                    <p class="text-secondary mb-2">Play when you hear the click!</p>
                    
                    <div class="calibration-beat" id="calibration-beat">
                        <i class="bi bi-music-note"></i>
                    </div>
                    
                    <div class="calibration-dots-container" id="calibration-dots">
                        <!-- Dots added dynamically -->
                    </div>
                    
                    <p class="text-muted" id="calibration-status">Get ready...</p>
                </div>
                
                <!-- Calibration Results -->
                <div id="calibration-results" style="display: none;">
                    <p class="text-secondary mb-3">Calibration Complete!</p>
                    
                    <div class="offset-display" id="calibration-result-offset">0ms</div>
                    <p class="text-muted mb-4" id="calibration-result-text">Your timing is perfect!</p>
                    
                    <div class="row mb-4">
                        <div class="col-6">
                            <div class="card">
                                <div class="card-body text-center py-3">
                                    <div class="h4 mb-0" id="calibration-avg-offset">0ms</div>
                                    <small class="text-muted">Average Offset</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="card">
                                <div class="card-body text-center py-3">
                                    <div class="h4 mb-0" id="calibration-consistency">0ms</div>
                                    <small class="text-muted">Consistency</small>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="d-flex gap-2 justify-content-center">
                        <button class="btn btn-outline-secondary" id="recalibrate-btn">
                            <i class="bi bi-arrow-repeat"></i> Recalibrate
                        </button>
                        <button class="btn btn-primary" id="apply-calibration-btn">
                            <i class="bi bi-check-lg"></i> Apply & Close
                        </button>
                    </div>
                    
                    <div class="mt-3">
                        <small class="text-muted">
                            <i class="bi bi-info-circle"></i> 
                            This offset will be saved and applied automatically in future sessions.
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Results Modal -->
<div class="modal fade" id="results-modal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-trophy"></i> Game Complete!</h5>
            </div>
            <div class="modal-body">
                <div id="new-high-score-banner" class="alert alert-warning text-center mb-4" style="display: none;">
                    <i class="bi bi-star-fill"></i> NEW HIGH SCORE! <i class="bi bi-star-fill"></i>
                </div>
                
                <div class="row mb-4">
                    <div class="col-md-4">
                        <div class="result-stat">
                            <div class="value" id="result-score">0</div>
                            <div class="label">Final Score</div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="result-stat">
                            <div class="value" id="result-accuracy">0%</div>
                            <div class="label">Accuracy</div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="result-stat">
                            <div class="value" id="result-streak">0</div>
                            <div class="label">Best Streak</div>
                        </div>
                    </div>
                </div>
                
                <h6 class="mb-2">Hit Breakdown</h6>
                <div class="timing-bar mb-3" id="timing-breakdown">
                    <!-- Filled dynamically -->
                </div>
                <div class="d-flex justify-content-between text-muted small mb-4">
                    <span><span class="badge" style="background:#22c55e">Perfect</span> <span id="result-perfect">0</span></span>
                    <span><span class="badge" style="background:#3b82f6">Good</span> <span id="result-good">0</span></span>
                    <span><span class="badge" style="background:#f59e0b;color:#000">Early</span> <span id="result-early">0</span></span>
                    <span><span class="badge" style="background:#fb923c;color:#000">Late</span> <span id="result-late">0</span></span>
                    <span><span class="badge bg-danger">Miss</span> <span id="result-miss">0</span></span>
                </div>
                
                <h6 class="mb-2">Tips</h6>
                <ul class="list-unstyled" id="result-tips">
                    <!-- Filled dynamically -->
                </ul>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Back to Menu</button>
                <button type="button" class="btn btn-primary" id="play-again-btn">
                    <i class="bi bi-arrow-repeat"></i> Play Again
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// =============================================================================
// Audio Input Handler
// =============================================================================
class AudioInputHandler {
    constructor() {
        this.audioContext = null;
        this.analyser = null;
        this.mediaStream = null;
        this.isConnected = false;
        this.threshold = 30;
        this.onNoteDetected = null;
        this.lastTriggerTime = 0;
        this.minTriggerInterval = 50; // Minimum ms between triggers
    }
    
    async connect(deviceId = null) {
        try {
            // Request microphone access
            const constraints = {
                audio: deviceId ? { deviceId: { exact: deviceId } } : true
            };
            
            this.mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Create audio context
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create analyser
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
            this.analyser.smoothingTimeConstant = 0.3;
            
            // Connect source to analyser
            const source = this.audioContext.createMediaStreamSource(this.mediaStream);
            source.connect(this.analyser);
            
            this.isConnected = true;
            this.startListening();
            
            return true;
        } catch (error) {
            console.error('Error connecting audio:', error);
            return false;
        }
    }
    
    disconnect() {
        if (this.mediaStream) {
            this.mediaStream.getTracks().forEach(track => track.stop());
        }
        if (this.audioContext) {
            this.audioContext.close();
        }
        this.isConnected = false;
    }
    
    startListening() {
        if (!this.isConnected) return;
        
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const checkLevel = () => {
            if (!this.isConnected) return;
            
            this.analyser.getByteFrequencyData(dataArray);
            
            // Calculate average volume (focus on bass frequencies)
            let sum = 0;
            const bassRange = Math.floor(bufferLength * 0.1); // Lower 10% = bass frequencies
            for (let i = 0; i < bassRange; i++) {
                sum += dataArray[i];
            }
            const average = sum / bassRange;
            const volume = (average / 255) * 100;
            
            // Update volume meter
            const meterFill = document.getElementById('volume-meter-fill');
            if (meterFill) {
                meterFill.style.width = Math.min(100, volume * 2) + '%';
            }
            
            // Update audio indicator
            const indicator = document.getElementById('audio-status');
            if (indicator) {
                if (volume > this.threshold) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                }
            }
            
            // Trigger note detection
            const now = performance.now();
            if (volume > this.threshold && (now - this.lastTriggerTime) > this.minTriggerInterval) {
                this.lastTriggerTime = now;
                if (this.onNoteDetected) {
                    this.onNoteDetected(now);
                }
            }
            
            requestAnimationFrame(checkLevel);
        };
        
        checkLevel();
    }
    
    setThreshold(value) {
        this.threshold = value;
    }
    
    static async getDevices() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.filter(d => d.kind === 'audioinput');
        } catch (error) {
            console.error('Error getting devices:', error);
            return [];
        }
    }
}

// =============================================================================
// Metronome
// =============================================================================
class Metronome {
    constructor() {
        this.audioContext = null;
        this.isPlaying = false;
        this.tempo = 80;
        this.nextNoteTime = 0;
        this.timerID = null;
    }
    
    init() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    playClick(time, isAccent = false) {
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(this.audioContext.destination);
        
        osc.frequency.value = isAccent ? 1000 : 800;
        gain.gain.value = isAccent ? 0.3 : 0.2;
        
        osc.start(time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
        osc.stop(time + 0.05);
    }
    
    playSubClick(time) {
        // Quieter, higher-pitched click for count-in
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(this.audioContext.destination);
        
        osc.frequency.value = 1200; // Higher pitch
        gain.gain.value = 0.1; // Quieter
        
        osc.start(time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.03);
        osc.stop(time + 0.03);
    }
    
    getCurrentTime() {
        return this.audioContext ? this.audioContext.currentTime * 1000 : 0;
    }
}

// =============================================================================
// Calibration Controller
// =============================================================================
class CalibrationController {
    constructor(audioHandler, metronome) {
        this.audioHandler = audioHandler;
        this.metronome = metronome;
        this.isCalibrating = false;
        this.calibrationClicks = 8;
        this.currentClick = 0;
        this.clickTimes = [];
        this.hitTimes = [];
        this.offsets = [];
        this.calibrationOffset = 0;
        this.pendingOffset = 0; // Offset calculated but not yet applied
        this.onComplete = null;
        
        // Load saved calibration
        this.loadCalibration();
    }
    
    loadCalibration() {
        try {
            const saved = localStorage.getItem('timing_calibration_offset');
            console.log('Loading calibration from localStorage:', saved);
            if (saved !== null) {
                this.calibrationOffset = parseFloat(saved);
                console.log('Calibration loaded:', this.calibrationOffset, 'ms');
            }
        } catch (e) {
            console.error('Error loading calibration:', e);
        }
    }
    
    saveCalibration() {
        try {
            localStorage.setItem('timing_calibration_offset', this.calibrationOffset.toString());
            console.log('Calibration saved to localStorage:', this.calibrationOffset);
            this.updateOffsetDisplay();
        } catch (e) {
            console.error('Error saving calibration:', e);
        }
    }
    
    updateOffsetDisplay() {
        const display = document.getElementById('calibration-offset-display');
        if (display) {
            const offset = Math.round(this.calibrationOffset);
            display.textContent = `${offset >= 0 ? '+' : ''}${offset}ms`;
            display.className = 'badge ' + (offset === 0 ? 'bg-success' : offset > 0 ? 'bg-warning' : 'bg-info');
        }
    }
    
    getOffset() {
        return this.calibrationOffset;
    }
    
    start() {
        console.log('Starting calibration...');
        this.isCalibrating = true;
        this.currentClick = 0;
        this.clickTimes = [];
        this.hitTimes = [];
        this.offsets = [];
        
        // Setup UI - show progress, hide others
        const instructionsEl = document.getElementById('calibration-instructions');
        const progressEl = document.getElementById('calibration-progress');
        const resultsEl = document.getElementById('calibration-results');
        
        console.log('Elements found:', { 
            instructions: !!instructionsEl, 
            progress: !!progressEl, 
            results: !!resultsEl 
        });
        
        if (instructionsEl) instructionsEl.style.display = 'none';
        if (progressEl) progressEl.style.display = 'block';
        if (resultsEl) resultsEl.style.display = 'none';
        
        // Create progress dots
        const dotsContainer = document.getElementById('calibration-dots');
        if (dotsContainer) {
            dotsContainer.innerHTML = '';
            for (let i = 0; i < this.calibrationClicks; i++) {
                const dot = document.createElement('div');
                dot.className = 'calibration-dot';
                dot.id = `cal-dot-${i}`;
                dotsContainer.appendChild(dot);
            }
        }
        
        // Ensure metronome audio context is running
        if (this.metronome.audioContext && this.metronome.audioContext.state === 'suspended') {
            this.metronome.audioContext.resume();
        }
        
        // Setup audio callback
        this.audioHandler.onNoteDetected = (time) => {
            if (this.isCalibrating && this.currentClick > 0) {
                this.registerHit(time);
            }
        };
        
        // Start the calibration sequence after a short delay
        const statusEl = document.getElementById('calibration-status');
        if (statusEl) statusEl.textContent = 'Get ready...';
        
        console.log('Starting calibration clicks in 1.5s...');
        setTimeout(() => this.playNextClick(), 1500);
    }
    
    playNextClick() {
        if (!this.isCalibrating) return;
        
        if (this.currentClick >= this.calibrationClicks) {
            this.complete();
            return;
        }
        
        // Update UI
        const dot = document.getElementById(`cal-dot-${this.currentClick}`);
        if (dot) {
            dot.classList.add('current');
        }
        
        const beat = document.getElementById('calibration-beat');
        const statusEl = document.getElementById('calibration-status');
        
        // Play 3 count-in sub-clicks before the main click
        const beatInterval = 500; // 120 BPM feel
        let subClick = 0;
        
        const playSubClick = () => {
            if (!this.isCalibrating) return;
            
            subClick++;
            
            if (subClick <= 3) {
                // Sub-click (quieter, higher pitch)
                this.metronome.playSubClick(this.metronome.audioContext.currentTime);
                if (statusEl) statusEl.textContent = `${4 - subClick}...`;
                
                // Small visual pulse for sub-clicks
                beat.style.transform = 'scale(1.05)';
                setTimeout(() => beat.style.transform = '', 50);
                
                setTimeout(playSubClick, beatInterval);
            } else {
                // Main click - this is the one to play on!
                if (statusEl) statusEl.textContent = `PLAY! (${this.currentClick + 1}/${this.calibrationClicks})`;
                
                // Flash the beat indicator
                beat.classList.add('flash');
                setTimeout(() => beat.classList.remove('flash'), 100);
                
                // Play main click and record time
                const clickTime = performance.now();
                this.clickTimes.push(clickTime);
                this.metronome.playClick(this.metronome.audioContext.currentTime, true);
                
                this.currentClick++;
                
                // Wait for hit or timeout
                this.hitTimeout = setTimeout(() => {
                    // Mark as missed if no hit received
                    if (this.hitTimes.length < this.currentClick) {
                        this.hitTimes.push(null);
                        const prevDot = document.getElementById(`cal-dot-${this.currentClick - 1}`);
                        if (prevDot) {
                            prevDot.classList.remove('current');
                            prevDot.classList.add('complete');
                        }
                    }
                    // Next click after a brief pause
                    setTimeout(() => this.playNextClick(), beatInterval);
                }, beatInterval * 1.5);
            }
        };
        
        // Start the count-in
        playSubClick();
    }
    
    registerHit(hitTime) {
        if (this.hitTimes.length >= this.currentClick) return; // Already got a hit for this click
        
        clearTimeout(this.hitTimeout);
        
        const clickTime = this.clickTimes[this.clickTimes.length - 1];
        const offset = hitTime - clickTime;
        
        this.hitTimes.push(hitTime);
        this.offsets.push(offset);
        
        // Update UI
        const beat = document.getElementById('calibration-beat');
        beat.classList.add('hit');
        setTimeout(() => beat.classList.remove('hit'), 200);
        
        const dot = document.getElementById(`cal-dot-${this.currentClick - 1}`);
        if (dot) {
            dot.classList.remove('current');
            dot.classList.add('complete');
        }
        
        // Next click after short delay
        setTimeout(() => this.playNextClick(), 700);
    }
    
    complete() {
        this.isCalibrating = false;
        this.audioHandler.onNoteDetected = null;
        
        // Calculate results
        const validOffsets = this.offsets.filter(o => o !== null && Math.abs(o) < 500);
        
        if (validOffsets.length < 3) {
            // Not enough valid hits
            document.getElementById('calibration-status').textContent = 'Not enough valid hits. Please try again.';
            setTimeout(() => {
                document.getElementById('calibration-instructions').style.display = 'block';
                document.getElementById('calibration-progress').style.display = 'none';
            }, 2000);
            return;
        }
        
        // Calculate average offset (this is the latency compensation)
        const avgOffset = validOffsets.reduce((a, b) => a + b, 0) / validOffsets.length;
        
        // Calculate consistency (standard deviation)
        const variance = validOffsets.reduce((sum, o) => sum + Math.pow(o - avgOffset, 2), 0) / validOffsets.length;
        const stdDev = Math.sqrt(variance);
        
        // The calibration offset is the NEGATIVE of the average offset
        // If user is hitting late (+50ms), we need to subtract 50ms from their hits
        // Store as pending until user clicks Apply
        this.pendingOffset = -Math.round(avgOffset);
        
        // Show results
        document.getElementById('calibration-progress').style.display = 'none';
        document.getElementById('calibration-results').style.display = 'block';
        
        const resultOffset = document.getElementById('calibration-result-offset');
        const offsetValue = Math.round(avgOffset);
        resultOffset.textContent = `${offsetValue >= 0 ? '+' : ''}${offsetValue}ms`;
        resultOffset.className = 'offset-display ' + 
            (Math.abs(offsetValue) < 20 ? 'neutral' : offsetValue > 0 ? 'positive' : 'negative');
        
        // Result text
        let resultText = '';
        if (Math.abs(offsetValue) < 20) {
            resultText = 'Your timing is excellent! Minimal latency detected.';
        } else if (offsetValue > 0) {
            resultText = `You're playing ${offsetValue}ms late on average. This will be compensated.`;
        } else {
            resultText = `You're playing ${Math.abs(offsetValue)}ms early on average. This will be compensated.`;
        }
        document.getElementById('calibration-result-text').textContent = resultText;
        
        document.getElementById('calibration-avg-offset').textContent = `${offsetValue >= 0 ? '+' : ''}${offsetValue}ms`;
        document.getElementById('calibration-consistency').textContent = `Â±${Math.round(stdDev)}ms`;
    }
    
    apply() {
        // Apply the pending offset
        this.calibrationOffset = this.pendingOffset;
        this.saveCalibration();
        console.log('Calibration applied and saved:', this.calibrationOffset, 'ms');
        if (this.onComplete) {
            this.onComplete(this.calibrationOffset);
        }
    }
    
    cancel() {
        this.isCalibrating = false;
        clearTimeout(this.hitTimeout);
        this.audioHandler.onNoteDetected = null;
    }
    
    reset() {
        document.getElementById('calibration-instructions').style.display = 'block';
        document.getElementById('calibration-progress').style.display = 'none';
        document.getElementById('calibration-results').style.display = 'none';
    }
}

// =============================================================================
// Game Controller
// =============================================================================
class TimingGame {
    constructor() {
        this.audioHandler = new AudioInputHandler();
        this.metronome = new Metronome();
        this.calibration = null; // Initialized after metronome
        this.sessionId = null;
        this.gameMode = 'groove';
        this.difficulty = 1;
        this.tempo = 80;
        this.durationBars = 8;
        this.isPlaying = false;
        this.beatTimes = [];
        this.currentNoteIndex = 0;
        this.score = 0;
        this.streak = 0;
        this.notesHit = 0;
        this.gameStartTime = 0;
        this.perfectWindow = 80;
        this.goodWindow = 150;
        this.noteElements = [];
        this.calibrationOffset = 0;
    }
    
    async init() {
        this.metronome.init();
        this.calibration = new CalibrationController(this.audioHandler, this.metronome);
        this.calibrationOffset = this.calibration.getOffset();
        // Update display now that DOM is ready
        this.calibration.updateOffsetDisplay();
        this.setupEventListeners();
        await this.loadAudioDevices();
    }
    
    async loadAudioDevices() {
        const devices = await AudioInputHandler.getDevices();
        const select = document.getElementById('audio-device-select');
        select.innerHTML = '';
        
        if (devices.length === 0) {
            select.innerHTML = '<option value="">No audio devices found</option>';
            return;
        }
        
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Audio Input ${select.children.length + 1}`;
            select.appendChild(option);
        });
    }
    
    setupEventListeners() {
        // Connect audio button
        document.getElementById('connect-audio-btn').addEventListener('click', async () => {
            const setupPanel = document.getElementById('audio-setup-panel');
            if (!this.audioHandler.isConnected) {
                setupPanel.style.display = 'block';
                const deviceId = document.getElementById('audio-device-select').value;
                const success = await this.audioHandler.connect(deviceId || null);
                
                if (success) {
                    document.getElementById('audio-status').classList.add('connected');
                    document.getElementById('audio-status-text').textContent = 'Connected';
                    document.getElementById('connect-audio-btn').innerHTML = '<i class="bi bi-mic-mute"></i> Disconnect';
                    document.getElementById('start-game-btn').disabled = false;
                } else {
                    alert('Could not connect to audio input. Please check permissions.');
                }
            } else {
                this.audioHandler.disconnect();
                document.getElementById('audio-status').classList.remove('connected');
                document.getElementById('audio-status-text').textContent = 'Not connected';
                document.getElementById('connect-audio-btn').innerHTML = '<i class="bi bi-mic"></i> Connect Audio';
                document.getElementById('start-game-btn').disabled = true;
                setupPanel.style.display = 'none';
            }
        });
        
        // Device select
        document.getElementById('audio-device-select').addEventListener('change', async (e) => {
            if (this.audioHandler.isConnected) {
                this.audioHandler.disconnect();
                await this.audioHandler.connect(e.target.value);
            }
        });
        
        // Threshold slider
        document.getElementById('threshold-slider').addEventListener('input', (e) => {
            this.audioHandler.setThreshold(parseInt(e.target.value));
        });
        
        // Calibration button
        document.getElementById('calibrate-btn').addEventListener('click', () => {
            if (!this.audioHandler.isConnected) {
                alert('Please connect your audio input first!');
                return;
            }
            this.calibration.reset();
            new bootstrap.Modal(document.getElementById('calibration-modal')).show();
        });
        
        // Start calibration
        document.getElementById('start-calibration-btn').addEventListener('click', () => {
            this.calibration.start();
        });
        
        // Recalibrate
        document.getElementById('recalibrate-btn').addEventListener('click', () => {
            this.calibration.reset();
            this.calibration.start();
        });
        
        // Apply calibration
        document.getElementById('apply-calibration-btn').addEventListener('click', () => {
            this.calibration.apply();
            this.calibrationOffset = this.calibration.getOffset();
            bootstrap.Modal.getInstance(document.getElementById('calibration-modal')).hide();
        });
        
        // Handle calibration modal close
        document.getElementById('calibration-modal').addEventListener('hidden.bs.modal', () => {
            this.calibration.cancel();
        });
        
        document.getElementById('calibration-close-btn').addEventListener('click', () => {
            this.calibration.cancel();
        });
        
        // Game mode selection
        document.querySelectorAll('.game-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.game-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                this.gameMode = card.dataset.mode;
            });
        });
        
        // Difficulty selection
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.difficulty = parseInt(btn.dataset.difficulty);
            });
        });
        
        // Random tempo
        document.getElementById('random-tempo-btn').addEventListener('click', () => {
            const tempoInput = document.getElementById('tempo-input');
            tempoInput.value = Math.floor(Math.random() * 80) + 60; // 60-140
        });
        
        // Start game
        document.getElementById('start-game-btn').addEventListener('click', () => this.startGame());
        
        // Stop game
        document.getElementById('stop-game-btn').addEventListener('click', () => this.stopGame());
        
        // Play again
        document.getElementById('play-again-btn').addEventListener('click', () => {
            bootstrap.Modal.getInstance(document.getElementById('results-modal')).hide();
            this.startGame();
        });
        
        // Handle modal close
        document.getElementById('results-modal').addEventListener('hidden.bs.modal', () => {
            document.getElementById('game-selection').style.display = 'block';
            document.getElementById('game-container').style.display = 'none';
        });
        
        // Also allow spacebar/keyboard to hit notes (fallback)
        document.addEventListener('keydown', (e) => {
            if (this.isPlaying && e.code === 'Space') {
                e.preventDefault();
                this.registerHit(performance.now() - this.gameStartTime);
            }
        });
    }
    
    async startGame() {
        // Get settings
        this.tempo = parseInt(document.getElementById('tempo-input').value) || 80;
        this.durationBars = parseInt(document.getElementById('duration-select').value) || 8;
        
        // Check game mode selected
        if (!document.querySelector('.game-card.selected')) {
            alert('Please select a game mode first!');
            return;
        }
        
        // Start the game on server
        try {
            const response = await fetch('/timing/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    game_mode: this.gameMode,
                    difficulty: this.difficulty,
                    tempo: this.tempo,
                    duration_bars: this.durationBars
                })
            });
            
            const data = await response.json();
            this.sessionId = data.session_id;
            this.beatTimes = data.beat_times;
            this.tempo = data.tempo;
            
            // Calculate timing windows based on tempo and calibration
            const beatInterval = 60000 / this.tempo;
            const absCalibration = Math.abs(this.calibrationOffset);
            
            // Base windows from difficulty, but ensure they account for calibration variance
            // The detection window should be at least as wide as the calibration offset
            // but never more than half a beat (to avoid detecting wrong notes)
            const maxWindow = beatInterval / 2;
            
            // Perfect window: base + some allowance for calibration variance
            // Good window: wider, accommodates more timing variance
            this.perfectWindow = Math.min(maxWindow * 0.4, Math.max(data.perfect_window_ms, absCalibration * 0.3));
            this.goodWindow = Math.min(maxWindow * 0.8, Math.max(data.good_window_ms, absCalibration * 0.5));
            
            // Detection window for finding closest note (wider than scoring windows)
            this.detectionWindow = maxWindow;
            
            console.log('Timing windows calculated:', {
                tempo: this.tempo,
                beatInterval: Math.round(beatInterval),
                calibrationOffset: this.calibrationOffset,
                perfectWindow: Math.round(this.perfectWindow),
                goodWindow: Math.round(this.goodWindow),
                detectionWindow: Math.round(this.detectionWindow)
            });
            
            document.getElementById('total-notes').textContent = data.total_notes;
            document.getElementById('current-tempo').textContent = data.tempo;
            
            // Update countdown info
            document.getElementById('countdown-tempo').textContent = data.tempo;
            const calibrationBadge = document.getElementById('countdown-calibration');
            if (this.calibrationOffset !== 0) {
                calibrationBadge.textContent = `${this.calibrationOffset > 0 ? '+' : ''}${this.calibrationOffset}ms latency compensation`;
                calibrationBadge.className = 'ms-3 badge bg-info';
            } else {
                calibrationBadge.textContent = 'No calibration';
                calibrationBadge.className = 'ms-3 badge bg-secondary';
            }
            
            // Setup audio handler callback
            this.audioHandler.onNoteDetected = (time) => {
                if (this.isPlaying) {
                    this.registerHit(time - this.gameStartTime);
                }
            };
            
            // Show game UI
            document.getElementById('game-selection').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            
            // Start countdown
            await this.showCountdown();
            
            // Start the actual game
            this.startGameLoop();
            
        } catch (error) {
            console.error('Error starting game:', error);
            alert('Error starting game. Please try again.');
        }
    }
    
    async showCountdown() {
        return new Promise(resolve => {
            const countdownScreen = document.getElementById('countdown-screen');
            const gameScreen = document.getElementById('game-screen');
            const countdownNumber = document.getElementById('countdown-number');
            
            countdownScreen.style.display = 'block';
            gameScreen.style.display = 'none';
            
            // Use tempo-synced count-in (1 bar = 4 beats before start)
            const beatInterval = 60000 / this.tempo;
            let beat = 0;
            const totalBeats = 4; // 1 bar count-in
            
            const playCountBeat = () => {
                beat++;
                
                if (beat <= totalBeats) {
                    // Show countdown number (4, 3, 2, 1)
                    countdownNumber.textContent = totalBeats - beat + 1;
                    
                    // Play click - accent on beat 1
                    const isAccent = beat === 1;
                    this.metronome.playClick(this.metronome.audioContext.currentTime, isAccent);
                    
                    // Schedule next beat
                    setTimeout(playCountBeat, beatInterval);
                } else {
                    // Count-in complete, start the game
                    countdownScreen.style.display = 'none';
                    gameScreen.style.display = 'block';
                    resolve();
                }
            };
            
            // Start the count-in
            playCountBeat();
        });
    }
    
    startGameLoop() {
        this.isPlaying = true;
        this.score = 0;
        this.streak = 0;
        this.notesHit = 0;
        this.currentNoteIndex = 0;
        
        // Add lead time so first note isn't at time 0
        // Give 2 beats of lead time at current tempo
        const beatDuration = 60000 / this.tempo;
        this.leadTime = beatDuration * 2;
        
        // Offset all beat times by the lead time
        this.adjustedBeatTimes = this.beatTimes.map(t => t + this.leadTime);
        
        this.gameStartTime = performance.now();
        
        console.log('Game started:', {
            tempo: this.tempo,
            leadTime: this.leadTime,
            originalBeatTimes: this.beatTimes.slice(0, 5),
            adjustedBeatTimes: this.adjustedBeatTimes.slice(0, 5),
            gameStartTime: this.gameStartTime
        });
        
        // Create note elements
        this.createNotes();
        
        // Start the metronome clicks (after lead time)
        setTimeout(() => this.startMetronome(), this.leadTime);
        
        // Start animation loop
        this.animationLoop();
    }
    
    createNotes() {
        const beatTrack = document.getElementById('beat-track');
        // Clear old notes (keep beat line)
        beatTrack.querySelectorAll('.beat-note').forEach(n => n.remove());
        
        this.noteElements = [];
        
        this.beatTimes.forEach((time, index) => {
            const note = document.createElement('div');
            note.className = 'beat-note';
            note.textContent = index + 1;
            note.style.left = '100%'; // Start off screen
            note.dataset.index = index;
            beatTrack.appendChild(note);
            this.noteElements.push(note);
        });
    }
    
    startMetronome() {
        const beatInterval = 60000 / this.tempo; // ms per beat
        let beatIndex = 0;
        
        const playBeat = () => {
            if (!this.isPlaying) return;
            
            const isAccent = beatIndex % 4 === 0;
            this.metronome.playClick(this.metronome.audioContext.currentTime, isAccent);
            beatIndex++;
            
            setTimeout(playBeat, beatInterval);
        };
        
        playBeat();
    }
    
    animationLoop() {
        if (!this.isPlaying) return;
        
        const currentTime = performance.now() - this.gameStartTime;
        
        // Use adjusted beat times (with lead time)
        const beatTimes = this.adjustedBeatTimes || this.beatTimes;
        const totalDuration = beatTimes[beatTimes.length - 1] + 1000;
        
        // Update progress
        const progress = (currentTime / totalDuration) * 100;
        document.getElementById('game-progress').style.width = Math.min(100, progress) + '%';
        
        // Update time remaining
        const remaining = Math.max(0, totalDuration - currentTime) / 1000;
        const mins = Math.floor(remaining / 60);
        const secs = Math.floor(remaining % 60);
        document.getElementById('time-remaining').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        
        // Animate notes
        const trackWidth = document.getElementById('beat-track').offsetWidth;
        const approachTime = 2000; // Notes take 2 seconds to reach the line
        
        // Use detection window for both visibility and miss detection
        const detectWindow = this.detectionWindow || 375;
        
        // Account for calibration offset in miss detection
        // If calibrationOffset is negative (user hits early), we need MORE time before marking missed
        // because their actual hit will arrive later than the calibrated time
        const calibrationBuffer = Math.abs(this.calibrationOffset || 0);
        const missWindow = detectWindow + calibrationBuffer;
        
        this.noteElements.forEach((note, index) => {
            const noteTime = beatTimes[index];
            const timeUntilNote = noteTime - currentTime;
            
            if (timeUntilNote > approachTime) {
                note.style.display = 'none';
            } else if (timeUntilNote > -missWindow) {
                // Keep note visible until past the miss window
                note.style.display = 'flex';
                // Position note based on time until it should be hit
                const position = 50 + (timeUntilNote / approachTime) * 50;
                note.style.left = position + '%';
            } else {
                // Hide notes that are past the miss window
                note.style.display = 'none';
            }
            
            // Check for missed notes - account for calibration buffer
            if (timeUntilNote < -missWindow && !note.classList.contains('missed') && 
                !note.classList.contains('hit-perfect') && !note.classList.contains('hit-good') &&
                !note.classList.contains('hit-early') && !note.classList.contains('hit-late')) {
                note.classList.add('missed');
                this.registerMiss(index);
            }
        });
        
        // Check if game is complete
        if (currentTime >= totalDuration) {
            this.endGame();
            return;
        }
        
        requestAnimationFrame(() => this.animationLoop());
    }
    
    async registerHit(hitTime) {
        // Apply calibration offset to the hit time
        const calibratedHitTime = hitTime + this.calibrationOffset;
        
        // Use adjusted beat times (with lead time)
        const beatTimes = this.adjustedBeatTimes || this.beatTimes;
        
        console.log('Hit detected:', {
            rawHitTime: hitTime,
            calibrationOffset: this.calibrationOffset,
            calibratedHitTime: calibratedHitTime,
            goodWindow: this.goodWindow,
            firstFiveBeatTimes: beatTimes.slice(0, 5).map(t => Math.round(t))
        });
        
        // Find the closest note that hasn't been hit yet
        let closestIndex = -1;
        let closestOffset = Infinity;
        
        // Debug: count notes by state
        let states = { available: 0, perfect: 0, good: 0, early: 0, late: 0, missed: 0 };
        
        for (let i = 0; i < beatTimes.length; i++) {
            const note = this.noteElements[i];
            const isHit = note.classList.contains('hit-perfect') || note.classList.contains('hit-good') ||
                note.classList.contains('hit-early') || note.classList.contains('hit-late');
            const isMissed = note.classList.contains('missed');
            
            if (isHit) {
                if (note.classList.contains('hit-perfect')) states.perfect++;
                else if (note.classList.contains('hit-good')) states.good++;
                else if (note.classList.contains('hit-early')) states.early++;
                else if (note.classList.contains('hit-late')) states.late++;
                continue;
            }
            if (isMissed) {
                states.missed++;
                continue;
            }
            
            states.available++;
            const offset = Math.abs(calibratedHitTime - beatTimes[i]);
            console.log(`  Note ${i}: beatTime=${Math.round(beatTimes[i])}, offset=${Math.round(offset)}, detectionWindow=${Math.round(this.detectionWindow)}`);
            
            if (offset < closestOffset && offset < this.detectionWindow) {
                closestOffset = offset;
                closestIndex = i;
            }
        }
        
        console.log('Note states:', states);
        console.log('Closest note:', closestIndex, 'offset:', Math.round(closestOffset));
        
        if (closestIndex === -1) {
            console.log('No valid note found to hit!');
            return;
        }

        // Send hit to server - convert back to original beat time scale (without lead time)
        // The server uses original beat_times starting at 0
        const serverHitTime = calibratedHitTime - (this.leadTime || 0);
        
        try {
            const response = await fetch('/timing/hit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.sessionId,
                    hit_time_ms: serverHitTime,
                    note_index: closestIndex
                })
            });
            
            const data = await response.json();
            
            // Update visuals
            const note = this.noteElements[closestIndex];
            note.classList.add('hit-' + data.quality);
            
            // Update score
            this.score += data.score;
            this.streak = data.streak;
            this.notesHit++;
            
            document.getElementById('current-score').textContent = this.score;
            document.getElementById('current-streak').textContent = this.streak;
            document.getElementById('notes-hit').textContent = this.notesHit;
            
            // Update feedback
            const feedback = document.getElementById('hit-feedback');
            feedback.className = 'hit-feedback ' + data.quality;
            feedback.textContent = data.quality.toUpperCase();
            
            const offsetText = data.is_early ? `${Math.abs(data.offset_ms).toFixed(0)}ms early` : 
                              data.offset_ms > 0 ? `${data.offset_ms.toFixed(0)}ms late` : 'Perfect!';
            document.getElementById('timing-offset').textContent = offsetText;
            
            // Update streak fire effect
            const streakDisplay = document.getElementById('streak-display');
            if (this.streak >= 5) {
                streakDisplay.classList.add('on-fire');
            } else {
                streakDisplay.classList.remove('on-fire');
            }
            
        } catch (error) {
            console.error('Error registering hit:', error);
        }
    }
    
    async registerMiss(noteIndex) {
        try {
            await fetch('/timing/miss', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.sessionId,
                    note_index: noteIndex
                })
            });
            
            this.streak = 0;
            document.getElementById('current-streak').textContent = '0';
            document.getElementById('streak-display').classList.remove('on-fire');
            
            const feedback = document.getElementById('hit-feedback');
            feedback.className = 'hit-feedback miss';
            feedback.textContent = 'MISS';
            document.getElementById('timing-offset').textContent = '';
            
        } catch (error) {
            console.error('Error registering miss:', error);
        }
    }
    
    stopGame() {
        this.isPlaying = false;
        this.endGame();
    }
    
    async endGame() {
        this.isPlaying = false;
        
        const duration = Math.floor((performance.now() - this.gameStartTime) / 1000);
        
        try {
            const response = await fetch('/timing/complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.sessionId,
                    duration_seconds: duration
                })
            });
            
            const data = await response.json();
            this.showResults(data);
            
        } catch (error) {
            console.error('Error completing game:', error);
        }
    }
    
    showResults(data) {
        const stats = data.stats;
        
        // Update result values
        document.getElementById('result-score').textContent = stats.total_score;
        document.getElementById('result-accuracy').textContent = stats.accuracy_percentage + '%';
        document.getElementById('result-streak').textContent = stats.best_streak;
        
        document.getElementById('result-perfect').textContent = stats.perfect_hits;
        document.getElementById('result-good').textContent = stats.good_hits;
        document.getElementById('result-early').textContent = stats.early_hits;
        document.getElementById('result-late').textContent = stats.late_hits;
        document.getElementById('result-miss').textContent = stats.missed_notes;
        
        // Build timing breakdown bar
        const total = stats.total_notes;
        const breakdown = document.getElementById('timing-breakdown');
        breakdown.innerHTML = '';
        
        if (stats.perfect_hits > 0) {
            const seg = document.createElement('div');
            seg.className = 'segment perfect';
            seg.style.width = (stats.perfect_hits / total * 100) + '%';
            seg.textContent = stats.perfect_hits;
            breakdown.appendChild(seg);
        }
        if (stats.good_hits > 0) {
            const seg = document.createElement('div');
            seg.className = 'segment good';
            seg.style.width = (stats.good_hits / total * 100) + '%';
            seg.textContent = stats.good_hits;
            breakdown.appendChild(seg);
        }
        if (stats.early_hits > 0) {
            const seg = document.createElement('div');
            seg.className = 'segment early';
            seg.style.width = (stats.early_hits / total * 100) + '%';
            seg.textContent = stats.early_hits;
            breakdown.appendChild(seg);
        }
        if (stats.late_hits > 0) {
            const seg = document.createElement('div');
            seg.className = 'segment late';
            seg.style.width = (stats.late_hits / total * 100) + '%';
            seg.textContent = stats.late_hits;
            breakdown.appendChild(seg);
        }
        if (stats.missed_notes > 0) {
            const seg = document.createElement('div');
            seg.className = 'segment miss';
            seg.style.width = (stats.missed_notes / total * 100) + '%';
            seg.textContent = stats.missed_notes;
            breakdown.appendChild(seg);
        }
        
        // Tips
        const tipsList = document.getElementById('result-tips');
        tipsList.innerHTML = '';
        data.tips.forEach(tip => {
            const li = document.createElement('li');
            li.className = 'mb-2';
            li.innerHTML = '<i class="bi bi-lightbulb text-warning me-2"></i>' + tip;
            tipsList.appendChild(li);
        });
        
        // High score banner
        document.getElementById('new-high-score-banner').style.display = 
            data.is_new_high_score ? 'block' : 'none';
        
        // Show modal
        new bootstrap.Modal(document.getElementById('results-modal')).show();
    }
}

// Initialize game
document.addEventListener('DOMContentLoaded', () => {
    const game = new TimingGame();
    game.init();
});
</script>
{% endblock %}
