{% extends "base.html" %}

{% block title %}Timing Practice - Bass Practice{% endblock %}

{% block extra_css %}
<style>
    .game-card {
        cursor: pointer;
        transition: all 0.3s ease;
        border: 2px solid transparent;
    }
    
    .game-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    }
    
    .game-card.selected {
        border-color: var(--primary-color);
    }
    
    .game-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
    }
    
    /* Game UI */
    #game-container {
        display: none;
    }
    
    .beat-track {
        position: relative;
        height: 120px;
        background: linear-gradient(90deg, var(--darker-bg) 0%, var(--card-bg) 50%, var(--darker-bg) 100%);
        border-radius: 12px;
        overflow: hidden;
        margin: 2rem 0;
    }
    
    .beat-line {
        position: absolute;
        left: 50%;
        top: 0;
        bottom: 0;
        width: 4px;
        background: var(--primary-color);
        box-shadow: 0 0 20px var(--primary-color);
        z-index: 10;
    }
    
    .beat-note {
        position: absolute;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--accent-color);
        top: 50%;
        transform: translateY(-50%);
        transition: left 0.016s linear;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
    
    .beat-note.hit-perfect {
        background: #22c55e;
        animation: hit-flash 0.3s ease;
    }
    
    .beat-note.hit-good {
        background: #3b82f6;
        animation: hit-flash 0.3s ease;
    }
    
    .beat-note.hit-early,
    .beat-note.hit-late {
        background: #f59e0b;
        animation: hit-flash 0.3s ease;
    }
    
    .beat-note.missed {
        background: #ef4444;
        opacity: 0.5;
    }
    
    @keyframes hit-flash {
        0% { transform: translateY(-50%) scale(1); }
        50% { transform: translateY(-50%) scale(1.3); }
        100% { transform: translateY(-50%) scale(1); }
    }
    
    /* Score display */
    .score-display {
        font-size: 4rem;
        font-weight: 700;
        font-family: 'Consolas', monospace;
        color: var(--primary-color);
        text-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
    }
    
    .streak-display {
        font-size: 1.5rem;
        color: var(--accent-color);
    }
    
    .streak-display.on-fire {
        animation: fire-pulse 0.5s ease infinite;
    }
    
    @keyframes fire-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    /* Hit feedback */
    .hit-feedback {
        font-size: 2rem;
        font-weight: 700;
        text-transform: uppercase;
        min-height: 3rem;
    }
    
    .hit-feedback.perfect { color: #22c55e; }
    .hit-feedback.good { color: #3b82f6; }
    .hit-feedback.early { color: #f59e0b; }
    .hit-feedback.late { color: #f59e0b; }
    .hit-feedback.miss { color: #ef4444; }
    
    /* Audio input indicator */
    .audio-indicator {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #6c7086;
        transition: all 0.1s ease;
    }
    
    .audio-indicator.connected {
        background: #22c55e;
        box-shadow: 0 0 10px #22c55e;
    }
    
    .audio-indicator.active {
        background: #f59e0b;
        transform: scale(1.2);
        box-shadow: 0 0 15px #f59e0b;
    }
    
    /* Volume meter */
    .volume-meter {
        width: 100%;
        height: 8px;
        background: var(--darker-bg);
        border-radius: 4px;
        overflow: hidden;
    }
    
    .volume-meter-fill {
        height: 100%;
        background: linear-gradient(90deg, #22c55e 0%, #f59e0b 70%, #ef4444 100%);
        transition: width 0.05s ease;
        width: 0%;
    }
    
    /* Difficulty buttons */
    .difficulty-btn {
        padding: 0.5rem 1rem;
        border-radius: 8px;
        border: 2px solid var(--card-bg);
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .difficulty-btn:hover {
        border-color: var(--primary-color);
    }
    
    .difficulty-btn.selected {
        background: var(--primary-color);
        border-color: var(--primary-color);
    }
    
    /* Results modal */
    .result-stat {
        text-align: center;
        padding: 1rem;
    }
    
    .result-stat .value {
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--primary-color);
    }
    
    .result-stat .label {
        color: var(--text-secondary);
        font-size: 0.9rem;
    }
    
    .timing-bar {
        display: flex;
        height: 30px;
        border-radius: 8px;
        overflow: hidden;
        background: var(--darker-bg);
    }
    
    .timing-bar .segment {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 600;
    }
    
    .timing-bar .perfect { background: #22c55e; color: white; }
    .timing-bar .good { background: #3b82f6; color: white; }
    .timing-bar .early { background: #f59e0b; color: black; }
    .timing-bar .late { background: #fb923c; color: black; }
    .timing-bar .miss { background: #ef4444; color: white; }
    
    /* Countdown */
    .countdown {
        font-size: 8rem;
        font-weight: 700;
        color: var(--primary-color);
        text-shadow: 0 0 50px rgba(99, 102, 241, 0.5);
        animation: countdown-pulse 1s ease infinite;
    }
    
    @keyframes countdown-pulse {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.1); opacity: 0.8; }
    }
    
    /* Calibration styles */
    .calibration-beat {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        background: var(--card-bg);
        border: 4px solid var(--primary-color);
        margin: 2rem auto;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        font-weight: bold;
        transition: all 0.1s ease;
    }
    
    .calibration-beat.flash {
        background: var(--primary-color);
        transform: scale(1.2);
        box-shadow: 0 0 30px var(--primary-color);
    }
    
    .calibration-beat.hit {
        background: #22c55e;
        border-color: #22c55e;
        box-shadow: 0 0 30px #22c55e;
    }
    
    .calibration-dots-container {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin: 1rem 0;
    }
    
    .calibration-dot {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--card-bg);
        border: 2px solid var(--text-muted);
    }
    
    .calibration-dot.complete {
        background: #22c55e;
        border-color: #22c55e;
    }
    
    .calibration-dot.current {
        border-color: var(--primary-color);
        animation: pulse-border 1s ease infinite;
    }
    
    @keyframes pulse-border {
        0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.5); }
        50% { box-shadow: 0 0 0 8px rgba(99, 102, 241, 0); }
    }
    
    .offset-display {
        font-size: 3rem;
        font-weight: 700;
        font-family: 'Consolas', monospace;
    }
    
    .offset-display.positive { color: #f59e0b; }
    .offset-display.negative { color: #3b82f6; }
    .offset-display.neutral { color: #22c55e; }
    
    /* Ok tier styles */
    .beat-note.hit-ok {
        background: #06b6d4;
        animation: hit-flash 0.3s ease;
    }
    
    .hit-feedback.ok { color: #06b6d4; }
    
    .timing-bar .ok { background: #06b6d4; color: white; }
    
    /* Large audio indicator for calibration */
    .audio-indicator.large {
        width: 60px;
        height: 60px;
    }
    
    /* Calibration step layout */
    .calibration-step {
        min-height: 280px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container py-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1><i class="bi bi-stopwatch"></i> Timing Practice</h1>
            <p class="text-secondary mb-0">Practice tight timing with your bass using audio input</p>
        </div>
        <div class="d-flex align-items-center gap-3">
            <div class="d-flex align-items-center gap-2">
                <span class="text-secondary">Audio:</span>
                <div class="audio-indicator" id="audio-status"></div>
                <span id="audio-status-text" class="text-muted small">Not connected</span>
            </div>
            <button class="btn btn-outline-primary" id="connect-audio-btn">
                <i class="bi bi-mic"></i> Connect Audio
            </button>
        </div>
    </div>
    
    <!-- Audio Setup Panel -->
    <div class="card mb-4" id="audio-setup-panel" style="display: none;">
        <div class="card-body">
            <h5 class="card-title"><i class="bi bi-sliders"></i> Audio Input Setup</h5>
            <div class="row align-items-center">
                <div class="col-md-4">
                    <label class="form-label">Select Audio Input</label>
                    <select class="form-select" id="audio-device-select">
                        <option value="">Loading devices...</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Input Level</label>
                    <div class="volume-meter">
                        <div class="volume-meter-fill" id="volume-meter-fill"></div>
                    </div>
                    <small class="text-muted">Threshold: <span id="threshold-value">Auto</span></small>
                </div>
                <div class="col-md-3">
                    <label class="form-label">System Latency</label>
                    <span id="calibration-offset-display" class="badge bg-secondary">Not calibrated</span>
                </div>
                <div class="col-md-2">
                    <label class="form-label">&nbsp;</label>
                    <button class="btn btn-outline-warning w-100" id="calibrate-btn">
                        <i class="bi bi-bullseye"></i> Calibrate
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Selection -->
    <div id="game-selection">
        <h3 class="mb-3">Choose Your Game</h3>
        <div class="row g-4 mb-4">
            {% for mode_id, mode in game_modes.items() %}
            <div class="col-md-4">
                <div class="card game-card h-100" data-mode="{{ mode_id }}">
                    <div class="card-body text-center">
                        <div class="game-icon" style="color: {{ mode.color }};">
                            <i class="bi bi-{{ mode.icon }}"></i>
                        </div>
                        <h4 class="card-title">{{ mode.name }}</h4>
                        <p class="card-text">{{ mode.description }}</p>
                        {% if high_scores.get(mode_id) %}
                        <div class="mt-3">
                            <span class="badge bg-warning text-dark">
                                <i class="bi bi-trophy"></i> High Score: {{ high_scores[mode_id].high_score }}
                            </span>
                        </div>
                        {% endif %}
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
        
        <!-- Game Settings -->
        <div class="card mb-4">
            <div class="card-body">
                <div class="row align-items-center">
                    <div class="col-md-4">
                        <label class="form-label">Difficulty</label>
                        <div class="btn-group d-flex" role="group">
                            {% for level, config in difficulty_levels.items() %}
                            <button type="button" class="difficulty-btn flex-fill {% if level == 1 %}selected{% endif %}" data-difficulty="{{ level }}">
                                {{ config.name }}
                            </button>
                            {% endfor %}
                        </div>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label">Tempo (BPM)</label>
                        <div class="input-group">
                            <input type="number" class="form-control" id="tempo-input" min="40" max="200" value="80">
                            <button class="btn btn-outline-secondary" type="button" id="random-tempo-btn" title="Random tempo">
                                <i class="bi bi-shuffle"></i>
                            </button>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label">Duration (bars)</label>
                        <select class="form-select" id="duration-select">
                            <option value="4">4 bars</option>
                            <option value="8" selected>8 bars</option>
                            <option value="16">16 bars</option>
                            <option value="32">32 bars (endurance)</option>
                        </select>
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                        <button class="btn btn-primary btn-lg w-100" id="start-game-btn" disabled>
                            <i class="bi bi-play-fill"></i> Start
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Stats Overview -->
        <div class="row g-4">
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{{ total_sessions }}</div>
                    <div class="stat-label">Total Sessions</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{{ total_notes }}</div>
                    <div class="stat-label">Notes Played</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{{ overall_accuracy }}%</div>
                    <div class="stat-label">Overall Accuracy</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card stat-card">
                    <div class="stat-value">{% if best_session %}{{ best_session.score }}{% else %}0{% endif %}</div>
                    <div class="stat-label">Best Score</div>
                </div>
            </div>
        </div>
        
        <!-- Recent Sessions -->
        {% if recent_sessions %}
        <div class="card mt-4">
            <div class="card-header">
                <h5 class="mb-0"><i class="bi bi-clock-history"></i> Recent Sessions</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-dark table-hover mb-0">
                        <thead>
                            <tr>
                                <th>Game</th>
                                <th>Tempo</th>
                                <th>Difficulty</th>
                                <th>Score</th>
                                <th>Accuracy</th>
                                <th>Perfect</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for session in recent_sessions %}
                            <tr>
                                <td>{{ game_modes[session.game_mode].name if session.game_mode in game_modes else session.game_mode }}</td>
                                <td>{{ session.tempo_bpm }} BPM</td>
                                <td>{{ difficulty_levels[session.difficulty].name if session.difficulty in difficulty_levels else session.difficulty }}</td>
                                <td><strong>{{ session.score }}</strong></td>
                                <td>{{ session.accuracy_percentage }}%</td>
                                <td>{{ session.perfect_percentage }}%</td>
                                <td>{{ session.created_at.strftime('%b %d, %H:%M') }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        {% endif %}
    </div>
    
    <!-- Game Container (Hidden until game starts) -->
    <div id="game-container">
        <!-- Countdown -->
        <div id="countdown-screen" class="text-center py-5" style="display: none;">
            <p class="text-secondary mb-3">
                <span id="countdown-tempo">80</span> BPM
                <span id="countdown-calibration" class="ms-3 badge bg-secondary">0ms offset</span>
            </p>
            <div class="countdown" id="countdown-number">4</div>
            <p class="text-muted mt-3">Listen for the clicks - game starts after the count-in!</p>
        </div>
        
        <!-- Game UI -->
        <div id="game-screen" style="display: none;">
            <div class="row mb-4">
                <div class="col-md-4 text-center">
                    <div class="score-display" id="current-score">0</div>
                    <div class="text-secondary">Score</div>
                </div>
                <div class="col-md-4 text-center">
                    <div class="hit-feedback" id="hit-feedback">&nbsp;</div>
                    <div id="timing-offset" class="text-muted"></div>
                </div>
                <div class="col-md-4 text-center">
                    <div class="streak-display" id="streak-display">
                        <i class="bi bi-fire"></i> <span id="current-streak">0</span>
                    </div>
                    <div class="text-secondary">Streak</div>
                </div>
            </div>
            
            <!-- Beat Track -->
            <div class="beat-track" id="beat-track">
                <div class="beat-line"></div>
                <!-- Notes will be added dynamically -->
            </div>
            
            <!-- Progress -->
            <div class="d-flex justify-content-between align-items-center mb-3">
                <span class="text-secondary">
                    <i class="bi bi-music-note"></i> <span id="notes-hit">0</span> / <span id="total-notes">0</span> notes
                </span>
                <span class="text-secondary">
                    <i class="bi bi-speedometer2"></i> <span id="current-tempo">80</span> BPM
                </span>
                <span class="text-secondary">
                    <i class="bi bi-clock"></i> <span id="time-remaining">0:00</span>
                </span>
            </div>
            
            <div class="progress mb-4" style="height: 8px;">
                <div class="progress-bar bg-primary" id="game-progress" style="width: 0%"></div>
            </div>
            
            <!-- Controls -->
            <div class="text-center">
                <button class="btn btn-outline-danger btn-lg" id="stop-game-btn">
                    <i class="bi bi-stop-fill"></i> Stop Game
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Calibration Modal -->
<div class="modal fade" id="calibration-modal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-bullseye"></i> Audio Calibration</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" id="calibration-close-btn"></button>
            </div>
            <div class="modal-body">
                
                <!-- Step 1: Threshold Calibration -->
                <div id="calibration-step-threshold" class="calibration-step text-center">
                    <h5 class="mb-4">Step 1: Audio Setup</h5>
                    
                    <!-- Sub-step 1a: Ambient noise -->
                    <div id="threshold-ambient">
                        <p class="text-secondary mb-3">Sampling ambient noise...</p>
                        <div class="alert alert-info">
                            <i class="bi bi-volume-mute"></i> <strong>Stay quiet</strong> for a moment
                        </div>
                        <div class="progress my-4" style="height: 8px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated bg-info" 
                                 id="ambient-progress" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <!-- Sub-step 1b: Signal confirmation -->
                    <div id="threshold-confirm" style="display: none;">
                        <p class="text-secondary mb-3">Now confirm your input</p>
                        <div class="alert alert-success">
                            <i class="bi bi-music-note"></i> <strong>Play a few notes</strong> on your bass
                        </div>
                        <div class="my-4">
                            <div class="audio-indicator large mx-auto" id="threshold-indicator"></div>
                        </div>
                        <p id="threshold-status" class="text-muted">Waiting for signal...</p>
                        <div class="calibration-dots-container mt-3" id="threshold-dots">
                            <div class="calibration-dot" id="thresh-dot-0"></div>
                            <div class="calibration-dot" id="thresh-dot-1"></div>
                            <div class="calibration-dot" id="thresh-dot-2"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Step 2: Latency Measurement -->
                <div id="calibration-step-latency" class="calibration-step text-center" style="display: none;">
                    <h5 class="mb-4">Step 2: Latency Measurement</h5>
                    
                    <div class="alert alert-warning mb-4">
                        <i class="bi bi-lightning"></i>
                        <strong>Reaction test:</strong> Play <strong>immediately</strong> when you hear the beep!
                        <br><small class="text-muted">This measures audio delay, not your timing skill.</small>
                    </div>
                    
                    <div class="calibration-beat" id="latency-beat">
                        <i class="bi bi-volume-up"></i>
                    </div>
                    
                    <div class="calibration-dots-container" id="latency-dots"></div>
                    
                    <p class="text-muted mt-3" id="latency-status">Get ready...</p>
                </div>
                
                <!-- Step 3: Results -->
                <div id="calibration-step-results" class="calibration-step text-center" style="display: none;">
                    <h5 class="mb-4"><i class="bi bi-check-circle text-success"></i> Calibration Complete!</h5>
                    
                    <div class="row mb-4">
                        <div class="col-6">
                            <div class="card">
                                <div class="card-body py-3">
                                    <div class="h3 mb-0" id="result-latency">0ms</div>
                                    <small class="text-muted">System Latency</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="card">
                                <div class="card-body py-3">
                                    <div class="h3 mb-0" id="result-threshold">30</div>
                                    <small class="text-muted">Input Threshold</small>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <p class="text-muted mb-4">
                        <i class="bi bi-info-circle"></i>
                        Settings saved automatically.
                    </p>
                    
                    <div class="d-flex gap-2 justify-content-center">
                        <button class="btn btn-outline-secondary" id="recalibrate-btn">
                            <i class="bi bi-arrow-repeat"></i> Redo
                        </button>
                        <button class="btn btn-primary" id="apply-calibration-btn">
                            <i class="bi bi-check-lg"></i> Apply & Close
                        </button>
                    </div>
                </div>
                
            </div>
        </div>
    </div>
</div>

<!-- Results Modal -->
<div class="modal fade" id="results-modal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-trophy"></i> Game Complete!</h5>
            </div>
            <div class="modal-body">
                <div id="new-high-score-banner" class="alert alert-warning text-center mb-4" style="display: none;">
                    <i class="bi bi-star-fill"></i> NEW HIGH SCORE! <i class="bi bi-star-fill"></i>
                </div>
                
                <div class="row mb-4">
                    <div class="col-md-4">
                        <div class="result-stat">
                            <div class="value" id="result-score">0</div>
                            <div class="label">Final Score</div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="result-stat">
                            <div class="value" id="result-accuracy">0%</div>
                            <div class="label">Accuracy</div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="result-stat">
                            <div class="value" id="result-streak">0</div>
                            <div class="label">Best Streak</div>
                        </div>
                    </div>
                </div>
                
                <h6 class="mb-2">Hit Breakdown</h6>
                <div class="timing-bar mb-3" id="timing-breakdown">
                    <!-- Filled dynamically -->
                </div>
                <div class="d-flex justify-content-between text-muted small mb-4">
                    <span><span class="badge" style="background:#22c55e">Perfect</span> <span id="result-perfect">0</span></span>
                    <span><span class="badge" style="background:#3b82f6">Good</span> <span id="result-good">0</span></span>
                    <span><span class="badge" style="background:#06b6d4">Ok</span> <span id="result-ok">0</span></span>
                    <span><span class="badge" style="background:#f59e0b;color:#000">Early</span> <span id="result-early">0</span></span>
                    <span><span class="badge" style="background:#fb923c;color:#000">Late</span> <span id="result-late">0</span></span>
                    <span><span class="badge bg-danger">Miss</span> <span id="result-miss">0</span></span>
                </div>
                
                <h6 class="mb-2">Tips</h6>
                <ul class="list-unstyled" id="result-tips">
                    <!-- Filled dynamically -->
                </ul>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Back to Menu</button>
                <button type="button" class="btn btn-primary" id="play-again-btn">
                    <i class="bi bi-arrow-repeat"></i> Play Again
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// =============================================================================
// Scoring Constants (mirror Python backend)
// =============================================================================
const SCORE_PERFECT = 100;
const SCORE_GOOD = 50;
const SCORE_OK = 25;
const SCORE_EARLY = 10;
const SCORE_LATE = 10;
const SCORE_MISS = 0;

const STREAK_MULTIPLIERS = {
    5: 1.5,
    10: 2.0,
    20: 2.5,
    50: 3.0,
    100: 4.0
};

// =============================================================================
// Audio Input Handler
// =============================================================================
class AudioInputHandler {
    constructor() {
        this.audioContext = null;
        this.analyser = null;
        this.mediaStream = null;
        this.isConnected = false;
        this.threshold = 30;
        this.noiseFloor = 0;
        this.onNoteDetected = null;
        this.lastTriggerTime = 0;
        this.minTriggerInterval = 50;
    }
    
    async connect(deviceId = null) {
        try {
            const constraints = {
                audio: deviceId ? { deviceId: { exact: deviceId } } : true
            };
            
            this.mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
            this.analyser.smoothingTimeConstant = 0.3;
            
            const source = this.audioContext.createMediaStreamSource(this.mediaStream);
            source.connect(this.analyser);
            
            this.isConnected = true;
            this.startListening();
            
            return true;
        } catch (error) {
            console.error('Error connecting audio:', error);
            return false;
        }
    }
    
    disconnect() {
        if (this.mediaStream) {
            this.mediaStream.getTracks().forEach(track => track.stop());
        }
        if (this.audioContext) {
            this.audioContext.close();
        }
        this.isConnected = false;
    }
    
    getCurrentVolume() {
        if (!this.analyser) return 0;
        
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);
        
        // Focus on bass frequencies (lower 5%)
        let sum = 0;
        const bassRange = Math.floor(bufferLength * 0.05);
        for (let i = 0; i < bassRange; i++) {
            sum += dataArray[i];
        }
        return (sum / bassRange / 255) * 100;
    }
    
    async calibrateThreshold(onProgress = null) {
        return new Promise((resolve) => {
            const samples = [];
            const sampleDuration = 1500;
            const startTime = performance.now();
            
            const sample = () => {
                if (!this.isConnected) {
                    resolve(false);
                    return;
                }
                
                const volume = this.getCurrentVolume();
                samples.push(volume);
                
                const elapsed = performance.now() - startTime;
                if (onProgress) {
                    onProgress(Math.min(100, (elapsed / sampleDuration) * 100));
                }
                
                if (elapsed < sampleDuration) {
                    requestAnimationFrame(sample);
                } else {
                    // 95th percentile as noise floor
                    samples.sort((a, b) => a - b);
                    const p95Index = Math.floor(samples.length * 0.95);
                    this.noiseFloor = samples[p95Index];
                    
                    // Threshold with margin above noise
                    this.threshold = Math.min(80, Math.max(10, this.noiseFloor + 15));
                    resolve(true);
                }
            };
            
            sample();
        });
    }
    
    startListening() {
        if (!this.isConnected) return;
        
        const checkLevel = () => {
            if (!this.isConnected) return;
            
            const volume = this.getCurrentVolume();
            
            // Update volume meter
            const meterFill = document.getElementById('volume-meter-fill');
            if (meterFill) {
                meterFill.style.width = Math.min(100, volume * 2) + '%';
            }
            
            // Update indicator
            const indicator = document.getElementById('audio-status');
            if (indicator) {
                indicator.classList.toggle('active', volume > this.threshold);
            }
            
            // Trigger detection
            const now = performance.now();
            if (volume > this.threshold && (now - this.lastTriggerTime) > this.minTriggerInterval) {
                this.lastTriggerTime = now;
                if (this.onNoteDetected) {
                    this.onNoteDetected(now);
                }
            }
            
            requestAnimationFrame(checkLevel);
        };
        
        checkLevel();
    }
    
    static async getDevices() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.filter(d => d.kind === 'audioinput');
        } catch (error) {
            return [];
        }
    }
}

// =============================================================================
// Metronome
// =============================================================================
class Metronome {
    constructor() {
        this.audioContext = null;
    }
    
    init() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    playClick(time, isAccent = false) {
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(this.audioContext.destination);
        
        osc.frequency.value = isAccent ? 1000 : 800;
        gain.gain.value = isAccent ? 0.3 : 0.2;
        
        osc.start(time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
        osc.stop(time + 0.05);
    }
    
    getCurrentTime() {
        return this.audioContext ? this.audioContext.currentTime * 1000 : 0;
    }
}

// =============================================================================
// Calibration Controller
// =============================================================================
class CalibrationController {
    constructor(audioHandler, metronome) {
        this.audioHandler = audioHandler;
        this.metronome = metronome;
        
        // Calibration state
        this.isCalibrating = false;
        this.currentStep = null;
        
        // Threshold calibration
        this.signalConfirmCount = 0;
        this.requiredConfirms = 3;
        
        // Latency calibration
        this.latencyClicks = 6;
        this.currentClick = 0;
        this.beepTime = 0;
        this.reactionTimes = [];
        this.reactionTimeout = null;
        
        // Results
        this.systemLatency = 0;
        this.calibrationOffset = 0;
        
        // Human reaction baseline (research: ~140-180ms for audio stimulus)
        this.humanReactionBaseline = 140;
        
        this.loadCalibration();
    }
    
    loadCalibration() {
        try {
            const savedLatency = localStorage.getItem('timing_system_latency');
            const savedThreshold = localStorage.getItem('timing_threshold');
            
            if (savedLatency !== null) {
                this.systemLatency = parseFloat(savedLatency);
                this.calibrationOffset = this.systemLatency;
            }
            if (savedThreshold !== null) {
                this.audioHandler.threshold = parseFloat(savedThreshold);
            }
            this.updateOffsetDisplay();
        } catch (e) {
            console.error('Error loading calibration:', e);
        }
    }
    
    saveCalibration() {
        try {
            localStorage.setItem('timing_system_latency', this.systemLatency.toString());
            localStorage.setItem('timing_threshold', this.audioHandler.threshold.toString());
            this.calibrationOffset = this.systemLatency;
            this.updateOffsetDisplay();
        } catch (e) {
            console.error('Error saving calibration:', e);
        }
    }
    
    updateOffsetDisplay() {
        const display = document.getElementById('calibration-offset-display');
        if (display) {
            if (this.systemLatency > 0) {
                display.textContent = `${this.systemLatency}ms`;
                display.className = 'badge bg-success';
            } else {
                display.textContent = 'Not calibrated';
                display.className = 'badge bg-secondary';
            }
        }
        
        const thresholdDisplay = document.getElementById('threshold-value');
        if (thresholdDisplay) {
            thresholdDisplay.textContent = Math.round(this.audioHandler.threshold);
        }
    }
    
    getOffset() {
        return this.calibrationOffset;
    }
    
    // Start the full calibration flow
    start() {
        this.isCalibrating = true;
        this.reset();
        this.startThresholdCalibration();
    }
    
    reset() {
        // Reset UI to initial state
        document.getElementById('calibration-step-threshold').style.display = 'block';
        document.getElementById('calibration-step-latency').style.display = 'none';
        document.getElementById('calibration-step-results').style.display = 'none';
        
        document.getElementById('threshold-ambient').style.display = 'block';
        document.getElementById('threshold-confirm').style.display = 'none';
        document.getElementById('ambient-progress').style.width = '0%';
        
        // Reset dots
        for (let i = 0; i < 3; i++) {
            const dot = document.getElementById(`thresh-dot-${i}`);
            if (dot) {
                dot.classList.remove('complete', 'current');
            }
        }
    }
    
    // Step 1a: Sample ambient noise
    async startThresholdCalibration() {
        this.currentStep = 'threshold-ambient';
        const progressBar = document.getElementById('ambient-progress');
        
        const success = await this.audioHandler.calibrateThreshold((progress) => {
            progressBar.style.width = progress + '%';
        });
        
        if (success && this.isCalibrating) {
            document.getElementById('threshold-ambient').style.display = 'none';
            document.getElementById('threshold-confirm').style.display = 'block';
            this.startSignalConfirmation();
        }
    }
    
    // Step 1b: Confirm signal detection
    startSignalConfirmation() {
        this.currentStep = 'threshold-confirm';
        this.signalConfirmCount = 0;
        
        const indicator = document.getElementById('threshold-indicator');
        const status = document.getElementById('threshold-status');
        
        document.getElementById('thresh-dot-0').classList.add('current');
        
        this.audioHandler.onNoteDetected = () => {
            if (!this.isCalibrating || this.currentStep !== 'threshold-confirm') return;
            
            // Visual feedback
            indicator.classList.add('active');
            setTimeout(() => indicator.classList.remove('active'), 200);
            
            // Update dots
            const currentDot = document.getElementById(`thresh-dot-${this.signalConfirmCount}`);
            if (currentDot) {
                currentDot.classList.remove('current');
                currentDot.classList.add('complete');
            }
            
            this.signalConfirmCount++;
            
            const nextDot = document.getElementById(`thresh-dot-${this.signalConfirmCount}`);
            if (nextDot) nextDot.classList.add('current');
            
            if (this.signalConfirmCount >= this.requiredConfirms) {
                this.audioHandler.onNoteDetected = null;
                status.innerHTML = '<i class="bi bi-check-circle text-success"></i> Input confirmed!';
                setTimeout(() => this.startLatencyCalibration(), 1000);
            } else {
                status.textContent = `Detected ${this.signalConfirmCount}/${this.requiredConfirms}...`;
            }
        };
        
        status.textContent = 'Play some notes...';
    }
    
    // Step 2: Measure system latency
    startLatencyCalibration() {
        this.currentStep = 'latency';
        
        document.getElementById('calibration-step-threshold').style.display = 'none';
        document.getElementById('calibration-step-latency').style.display = 'block';
        
        this.currentClick = 0;
        this.reactionTimes = [];
        
        const dotsContainer = document.getElementById('latency-dots');
        dotsContainer.innerHTML = '';
        for (let i = 0; i < this.latencyClicks; i++) {
            const dot = document.createElement('div');
            dot.className = 'calibration-dot';
            dot.id = `latency-dot-${i}`;
            dotsContainer.appendChild(dot);
        }
        
        this.audioHandler.onNoteDetected = (time) => {
            if (this.currentStep === 'latency') this.recordReaction(time);
        };
        
        if (this.metronome.audioContext?.state === 'suspended') {
            this.metronome.audioContext.resume();
        }
        
        setTimeout(() => this.playLatencyBeep(), 1000);
    }
    
    playLatencyBeep() {
        if (!this.isCalibrating || this.currentStep !== 'latency') return;
        
        if (this.currentClick >= this.latencyClicks) {
            this.completeCalibration();
            return;
        }
        
        const beat = document.getElementById('latency-beat');
        const status = document.getElementById('latency-status');
        const dot = document.getElementById(`latency-dot-${this.currentClick}`);
        
        if (dot) dot.classList.add('current');
        
        const randomDelay = 1000 + Math.random() * 1500;
        status.textContent = 'Wait for it...';
        
        setTimeout(() => {
            if (!this.isCalibrating || this.currentStep !== 'latency') return;
            
            this.beepTime = performance.now();
            this.metronome.playClick(this.metronome.audioContext.currentTime, true);
            
            beat.classList.add('flash');
            setTimeout(() => beat.classList.remove('flash'), 100);
            
            status.textContent = 'NOW!';
            
            this.reactionTimeout = setTimeout(() => {
                if (this.reactionTimes.length <= this.currentClick) {
                    this.reactionTimes.push(null);
                    if (dot) dot.classList.remove('current');
                    this.currentClick++;
                    this.playLatencyBeep();
                }
            }, 1000);
            
        }, randomDelay);
    }
    
    recordReaction(hitTime) {
        if (this.reactionTimes.length > this.currentClick) return;
        
        clearTimeout(this.reactionTimeout);
        
        const reactionTime = hitTime - this.beepTime;
        this.reactionTimes.push(reactionTime);
        
        const beat = document.getElementById('latency-beat');
        const dot = document.getElementById(`latency-dot-${this.currentClick}`);
        
        beat.classList.add('hit');
        setTimeout(() => beat.classList.remove('hit'), 200);
        
        if (dot) {
            dot.classList.remove('current');
            dot.classList.add('complete');
        }
        
        this.currentClick++;
        setTimeout(() => this.playLatencyBeep(), 600);
    }
    
    completeCalibration() {
        this.currentStep = 'results';
        this.audioHandler.onNoteDetected = null;
        
        const validReactions = this.reactionTimes.filter(r => r !== null && r > 50 && r < 500);
        
        if (validReactions.length < 3) {
            document.getElementById('latency-status').textContent = 'Not enough responses. Retrying...';
            setTimeout(() => {
                this.reset();
                this.startThresholdCalibration();
            }, 2000);
            return;
        }
        
        validReactions.sort((a, b) => a - b);
        const fastestThree = validReactions.slice(0, 3);
        const avgFastest = fastestThree.reduce((a, b) => a + b, 0) / fastestThree.length;
        
        this.systemLatency = Math.round(Math.max(0, Math.min(100, avgFastest - this.humanReactionBaseline)));
        
        document.getElementById('calibration-step-latency').style.display = 'none';
        document.getElementById('calibration-step-results').style.display = 'block';
        
        document.getElementById('result-latency').textContent = `${this.systemLatency}ms`;
        document.getElementById('result-threshold').textContent = Math.round(this.audioHandler.threshold);
    }
    
    apply() {
        this.saveCalibration();
    }
    
    cancel() {
        this.isCalibrating = false;
        this.currentStep = null;
        clearTimeout(this.reactionTimeout);
        this.audioHandler.onNoteDetected = null;
    }
}

// =============================================================================
// Game Controller
// =============================================================================
class TimingGame {
    constructor() {
        this.audioHandler = new AudioInputHandler();
        this.metronome = new Metronome();
        this.calibration = null;
        
        // Game state
        this.sessionId = null;
        this.gameMode = 'groove';
        this.difficulty = 1;
        this.tempo = 80;
        this.durationBars = 8;
        this.isPlaying = false;
        
        // Timing data
        this.beatTimes = [];
        this.adjustedBeatTimes = [];
        this.leadTime = 0;
        this.gameStartTime = 0;
        
        // Scoring windows
        this.perfectWindow = 80;
        this.goodWindow = 150;
        this.detectionWindow = 375;
        
        // Score tracking
        this.score = 0;
        this.streak = 0;
        this.bestStreak = 0;
        this.notesHit = 0;
        this.hits = [];
        
        // DOM elements
        this.noteElements = [];
        
        // Calibration
        this.calibrationOffset = 0;
    }
    
    async init() {
        this.metronome.init();
        this.calibration = new CalibrationController(this.audioHandler, this.metronome);
        this.calibrationOffset = this.calibration.getOffset();
        this.calibration.updateOffsetDisplay();
        this.setupEventListeners();
        await this.loadAudioDevices();
    }
    
    async loadAudioDevices() {
        const devices = await AudioInputHandler.getDevices();
        const select = document.getElementById('audio-device-select');
        select.innerHTML = '';
        
        if (devices.length === 0) {
            select.innerHTML = '<option value="">No audio devices found</option>';
            return;
        }
        
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Audio Input ${select.children.length + 1}`;
            select.appendChild(option);
        });
    }
    
    setupEventListeners() {
        // Connect audio
        document.getElementById('connect-audio-btn').addEventListener('click', async () => {
            const setupPanel = document.getElementById('audio-setup-panel');
            if (!this.audioHandler.isConnected) {
                setupPanel.style.display = 'block';
                const deviceId = document.getElementById('audio-device-select').value;
                const success = await this.audioHandler.connect(deviceId || null);
                
                if (success) {
                    document.getElementById('audio-status').classList.add('connected');
                    document.getElementById('audio-status-text').textContent = 'Connected';
                    document.getElementById('connect-audio-btn').innerHTML = '<i class="bi bi-mic-mute"></i> Disconnect';
                    document.getElementById('start-game-btn').disabled = false;
                }
            } else {
                this.audioHandler.disconnect();
                document.getElementById('audio-status').classList.remove('connected');
                document.getElementById('audio-status-text').textContent = 'Not connected';
                document.getElementById('connect-audio-btn').innerHTML = '<i class="bi bi-mic"></i> Connect Audio';
                document.getElementById('start-game-btn').disabled = true;
                setupPanel.style.display = 'none';
            }
        });
        
        // Device select
        document.getElementById('audio-device-select').addEventListener('change', async (e) => {
            if (this.audioHandler.isConnected) {
                this.audioHandler.disconnect();
                await this.audioHandler.connect(e.target.value);
            }
        });
        
        // Calibration
        document.getElementById('calibrate-btn').addEventListener('click', () => {
            if (!this.audioHandler.isConnected) {
                alert('Please connect audio first!');
                return;
            }
            new bootstrap.Modal(document.getElementById('calibration-modal')).show();
            setTimeout(() => this.calibration.start(), 300);
        });
        
        document.getElementById('recalibrate-btn').addEventListener('click', () => {
            this.calibration.start();
        });
        
        document.getElementById('apply-calibration-btn').addEventListener('click', () => {
            this.calibration.apply();
            this.calibrationOffset = this.calibration.getOffset();
            bootstrap.Modal.getInstance(document.getElementById('calibration-modal')).hide();
        });
        
        document.getElementById('calibration-modal').addEventListener('hidden.bs.modal', () => {
            this.calibration.cancel();
        });
        
        // Game mode selection
        document.querySelectorAll('.game-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.game-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                this.gameMode = card.dataset.mode;
            });
        });
        
        // Difficulty selection
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.difficulty = parseInt(btn.dataset.difficulty);
            });
        });
        
        // Random tempo
        document.getElementById('random-tempo-btn').addEventListener('click', () => {
            document.getElementById('tempo-input').value = Math.floor(Math.random() * 80) + 60;
        });
        
        // Start/Stop game
        document.getElementById('start-game-btn').addEventListener('click', () => this.startGame());
        document.getElementById('stop-game-btn').addEventListener('click', () => this.stopGame());
        
        // Play again
        document.getElementById('play-again-btn').addEventListener('click', () => {
            bootstrap.Modal.getInstance(document.getElementById('results-modal')).hide();
            this.startGame();
        });
        
        // Results modal close
        document.getElementById('results-modal').addEventListener('hidden.bs.modal', () => {
            document.getElementById('game-selection').style.display = 'block';
            document.getElementById('game-container').style.display = 'none';
        });
        
        // Keyboard fallback
        document.addEventListener('keydown', (e) => {
            if (this.isPlaying && e.code === 'Space') {
                e.preventDefault();
                this.registerHit(performance.now() - this.gameStartTime);
            }
        });
    }
    
    async startGame() {
        this.tempo = parseInt(document.getElementById('tempo-input').value) || 80;
        this.durationBars = parseInt(document.getElementById('duration-select').value) || 8;
        
        if (!document.querySelector('.game-card.selected')) {
            alert('Please select a game mode!');
            return;
        }
        
        try {
            const response = await fetch('/timing/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    game_mode: this.gameMode,
                    difficulty: this.difficulty,
                    tempo: this.tempo,
                    duration_bars: this.durationBars
                })
            });
            
            const data = await response.json();
            this.sessionId = data.session_id;
            this.beatTimes = data.beat_times;
            this.tempo = data.tempo;
            
            // Calculate timing windows
            const beatInterval = 60000 / this.tempo;
            this.perfectWindow = data.perfect_window_ms;
            this.goodWindow = data.good_window_ms;
            this.detectionWindow = Math.min(beatInterval / 2, data.good_window_ms * 1.5);
            
            document.getElementById('total-notes').textContent = data.total_notes;
            document.getElementById('current-tempo').textContent = data.tempo;
            
            // Audio handler callback
            this.audioHandler.onNoteDetected = (time) => {
                if (this.isPlaying) {
                    this.registerHit(time - this.gameStartTime);
                }
            };
            
            // Show game UI
            document.getElementById('game-selection').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            
            await this.showCountdown();
            this.startGameLoop();
            
        } catch (error) {
            console.error('Error starting game:', error);
            alert('Error starting game.');
        }
    }
    
    async showCountdown() {
        return new Promise(resolve => {
            const countdownScreen = document.getElementById('countdown-screen');
            const gameScreen = document.getElementById('game-screen');
            const countdownNumber = document.getElementById('countdown-number');
            
            countdownScreen.style.display = 'block';
            gameScreen.style.display = 'none';
            
            document.getElementById('countdown-tempo').textContent = this.tempo;
            
            const beatInterval = 60000 / this.tempo;
            let beat = 0;
            const totalBeats = 4;
            
            const playCountBeat = () => {
                beat++;
                
                if (beat <= totalBeats) {
                    countdownNumber.textContent = totalBeats - beat + 1;
                    this.metronome.playClick(this.metronome.audioContext.currentTime, beat === 1);
                    setTimeout(playCountBeat, beatInterval);
                } else {
                    countdownScreen.style.display = 'none';
                    gameScreen.style.display = 'block';
                    resolve();
                }
            };
            
            playCountBeat();
        });
    }
    
    startGameLoop() {
        this.isPlaying = true;
        this.score = 0;
        this.streak = 0;
        this.bestStreak = 0;
        this.notesHit = 0;
        this.hits = [];
        
        // Lead time: 2 beats
        const beatDuration = 60000 / this.tempo;
        this.leadTime = beatDuration * 2;
        this.adjustedBeatTimes = this.beatTimes.map(t => t + this.leadTime);
        
        this.gameStartTime = performance.now();
        
        this.createNotes();
        setTimeout(() => this.startMetronome(), this.leadTime);
        this.animationLoop();
    }
    
    createNotes() {
        const beatTrack = document.getElementById('beat-track');
        beatTrack.querySelectorAll('.beat-note').forEach(n => n.remove());
        
        this.noteElements = [];
        
        this.beatTimes.forEach((time, index) => {
            const note = document.createElement('div');
            note.className = 'beat-note';
            note.textContent = index + 1;
            note.style.left = '100%';
            note.dataset.index = index;
            beatTrack.appendChild(note);
            this.noteElements.push(note);
        });
    }
    
    startMetronome() {
        const beatInterval = 60000 / this.tempo;
        let beatIndex = 0;
        
        const playBeat = () => {
            if (!this.isPlaying) return;
            
            this.metronome.playClick(this.metronome.audioContext.currentTime, beatIndex % 4 === 0);
            beatIndex++;
            setTimeout(playBeat, beatInterval);
        };
        
        playBeat();
    }
    
    animationLoop() {
        if (!this.isPlaying) return;
        
        const currentTime = performance.now() - this.gameStartTime;
        const beatTimes = this.adjustedBeatTimes;
        const totalDuration = beatTimes[beatTimes.length - 1] + 1000;
        
        // Progress
        document.getElementById('game-progress').style.width = Math.min(100, (currentTime / totalDuration) * 100) + '%';
        
        // Time remaining
        const remaining = Math.max(0, totalDuration - currentTime) / 1000;
        document.getElementById('time-remaining').textContent = 
            `${Math.floor(remaining / 60)}:${Math.floor(remaining % 60).toString().padStart(2, '0')}`;
        
        // Animate notes
        const approachTime = 2000;
        const MISS_GRACE_PERIOD = 150;
        
        this.noteElements.forEach((note, index) => {
            const noteTime = beatTimes[index];
            const timeUntilNote = noteTime - currentTime;
            
            // Position
            if (timeUntilNote > approachTime) {
                note.style.display = 'none';
            } else if (timeUntilNote > -this.detectionWindow - 200) {
                note.style.display = 'flex';
                note.style.left = (50 + (timeUntilNote / approachTime) * 50) + '%';
            } else {
                note.style.display = 'none';
            }
            
            // Miss detection with grace period
            if (timeUntilNote < -this.detectionWindow && !this.isNoteProcessed(note)) {
                if (!note.dataset.pendingMissAt) {
                    note.dataset.pendingMissAt = performance.now().toString();
                }
                
                const pendingTime = parseFloat(note.dataset.pendingMissAt);
                if (performance.now() - pendingTime > MISS_GRACE_PERIOD && !this.isNoteProcessed(note)) {
                    note.classList.add('missed');
                    this.registerMiss(index);
                }
            }
        });
        
        // Game complete check
        if (currentTime >= totalDuration) {
            this.endGame();
            return;
        }
        
        requestAnimationFrame(() => this.animationLoop());
    }
    
    // CLIENT-SIDE hit quality calculation
    calculateHitQuality(offsetMs) {
        const absOffset = Math.abs(offsetMs);
        const isEarly = offsetMs < 0;
        
        if (absOffset <= this.perfectWindow) {
            return { quality: 'perfect', score: SCORE_PERFECT, isEarly };
        } else if (absOffset <= this.goodWindow) {
            return { quality: 'good', score: SCORE_GOOD, isEarly };
        } else if (absOffset <= this.detectionWindow) {
            return { quality: 'ok', score: SCORE_OK, isEarly };
        } else if (isEarly) {
            return { quality: 'early', score: SCORE_EARLY, isEarly: true };
        } else {
            return { quality: 'late', score: SCORE_LATE, isEarly: false };
        }
    }
    
    getStreakMultiplier() {
        let multiplier = 1.0;
        for (const [threshold, mult] of Object.entries(STREAK_MULTIPLIERS)) {
            if (this.streak >= parseInt(threshold)) {
                multiplier = mult;
            }
        }
        return multiplier;
    }
    
    getFirstUnhitNoteIndex() {
        for (let i = 0; i < this.noteElements.length; i++) {
            if (!this.isNoteProcessed(this.noteElements[i])) {
                return i;
            }
        }
        return -1;
    }
    
    isNoteProcessed(note) {
        return note.classList.contains('hit-perfect') || 
               note.classList.contains('hit-good') ||
               note.classList.contains('hit-ok') ||
               note.classList.contains('hit-early') || 
               note.classList.contains('hit-late') ||
               note.classList.contains('missed');
    }
    
    getRelaxedFirstNoteWindow() {
        return 60000 / this.tempo; // 1 beat
    }
    
    // CLIENT-SIDE hit registration (no network call!)
    registerHit(hitTime) {
        const calibratedHitTime = hitTime - this.calibrationOffset;
        const beatTimes = this.adjustedBeatTimes;
        
        const firstUnhitIndex = this.getFirstUnhitNoteIndex();
        let closestIndex = -1;
        let closestOffset = Infinity;
        
        for (let i = 0; i < beatTimes.length; i++) {
            const note = this.noteElements[i];
            if (this.isNoteProcessed(note)) continue;
            
            const offset = calibratedHitTime - beatTimes[i];
            const absOffset = Math.abs(offset);
            
            // Relaxed window for first note
            const earlyBound = (i === firstUnhitIndex) ? this.getRelaxedFirstNoteWindow() : this.detectionWindow;
            const lateBound = this.detectionWindow;
            
            if (offset >= -earlyBound && offset <= lateBound) {
                if (absOffset < Math.abs(closestOffset)) {
                    closestOffset = offset;
                    closestIndex = i;
                }
            }
        }
        
        if (closestIndex === -1) return;
        
        // Calculate quality CLIENT-SIDE
        const { quality, score, isEarly } = this.calculateHitQuality(closestOffset);
        
        // Update streak
        if (quality === 'perfect' || quality === 'good' || quality === 'ok') {
            this.streak++;
            this.bestStreak = Math.max(this.bestStreak, this.streak);
        } else {
            this.streak = 0;
        }
        
        // Apply multiplier
        const finalScore = Math.floor(score * this.getStreakMultiplier());
        
        // Store hit
        this.hits.push({
            note_index: closestIndex,
            offset_ms: closestOffset,
            quality: quality,
            score: finalScore
        });
        
        // Update visuals IMMEDIATELY
        const note = this.noteElements[closestIndex];
        note.classList.add('hit-' + quality);
        
        this.score += finalScore;
        this.notesHit++;
        
        document.getElementById('current-score').textContent = this.score;
        document.getElementById('current-streak').textContent = this.streak;
        document.getElementById('notes-hit').textContent = this.notesHit;
        
        const feedback = document.getElementById('hit-feedback');
        feedback.className = 'hit-feedback ' + quality;
        feedback.textContent = quality.toUpperCase();
        
        document.getElementById('timing-offset').textContent = isEarly ? 
            `${Math.abs(closestOffset).toFixed(0)}ms early` : 
            closestOffset > 0 ? `${closestOffset.toFixed(0)}ms late` : 'Perfect!';
        
        document.getElementById('streak-display').classList.toggle('on-fire', this.streak >= 5);
    }
    
    // CLIENT-SIDE miss registration (no network call!)
    registerMiss(noteIndex) {
        this.hits.push({
            note_index: noteIndex,
            offset_ms: null,
            quality: 'miss',
            score: 0
        });
        
        this.streak = 0;
        document.getElementById('current-streak').textContent = '0';
        document.getElementById('streak-display').classList.remove('on-fire');
        
        const feedback = document.getElementById('hit-feedback');
        feedback.className = 'hit-feedback miss';
        feedback.textContent = 'MISS';
        document.getElementById('timing-offset').textContent = '';
    }
    
    stopGame() {
        this.isPlaying = false;
        this.endGame();
    }
    
    // Send all hits at game end (single network call)
    async endGame() {
        this.isPlaying = false;
        
        const duration = Math.floor((performance.now() - this.gameStartTime) / 1000);
        
        try {
            const response = await fetch('/timing/complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.sessionId,
                    duration_seconds: duration,
                    hits: this.hits  // All hits sent at once
                })
            });
            
            const data = await response.json();
            this.showResults(data);
            
        } catch (error) {
            console.error('Error completing game:', error);
            // Fallback to client-calculated results
            this.showResults({
                stats: this.calculateClientStats(),
                tips: ['Session completed.'],
                is_new_high_score: false
            });
        }
    }
    
    calculateClientStats() {
        let perfect = 0, good = 0, ok = 0, early = 0, late = 0, miss = 0;
        let totalScore = 0;
        const offsets = [];
        
        for (const hit of this.hits) {
            totalScore += hit.score;
            if (hit.quality === 'perfect') { perfect++; if (hit.offset_ms !== null) offsets.push(hit.offset_ms); }
            else if (hit.quality === 'good') { good++; if (hit.offset_ms !== null) offsets.push(hit.offset_ms); }
            else if (hit.quality === 'ok') { ok++; if (hit.offset_ms !== null) offsets.push(hit.offset_ms); }
            else if (hit.quality === 'early') { early++; }
            else if (hit.quality === 'late') { late++; }
            else { miss++; }
        }
        
        const total = this.hits.length;
        const accurate = perfect + good + ok;
        
        return {
            total_score: totalScore,
            total_notes: total,
            perfect_hits: perfect,
            good_hits: good,
            ok_hits: ok,
            early_hits: early,
            late_hits: late,
            missed_notes: miss,
            best_streak: this.bestStreak,
            accuracy_percentage: total ? Math.round(accurate / total * 1000) / 10 : 0,
            average_timing_ms: offsets.length ? Math.round(offsets.reduce((a,b) => a+b, 0) / offsets.length * 100) / 100 : 0
        };
    }
    
    showResults(data) {
        const stats = data.stats;
        
        document.getElementById('result-score').textContent = stats.total_score;
        document.getElementById('result-accuracy').textContent = stats.accuracy_percentage + '%';
        document.getElementById('result-streak').textContent = stats.best_streak;
        
        document.getElementById('result-perfect').textContent = stats.perfect_hits;
        document.getElementById('result-good').textContent = stats.good_hits;
        document.getElementById('result-ok').textContent = stats.ok_hits || 0;
        document.getElementById('result-early').textContent = stats.early_hits;
        document.getElementById('result-late').textContent = stats.late_hits;
        document.getElementById('result-miss').textContent = stats.missed_notes;
        
        // Timing breakdown bar
        const total = stats.total_notes;
        const breakdown = document.getElementById('timing-breakdown');
        breakdown.innerHTML = '';
        
        const segments = [
            { class: 'perfect', count: stats.perfect_hits },
            { class: 'good', count: stats.good_hits },
            { class: 'ok', count: stats.ok_hits || 0 },
            { class: 'early', count: stats.early_hits },
            { class: 'late', count: stats.late_hits },
            { class: 'miss', count: stats.missed_notes },
        ];
        
        segments.forEach(seg => {
            if (seg.count > 0) {
                const div = document.createElement('div');
                div.className = 'segment ' + seg.class;
                div.style.width = (seg.count / total * 100) + '%';
                div.textContent = seg.count;
                breakdown.appendChild(div);
            }
        });
        
        // Tips
        const tipsList = document.getElementById('result-tips');
        tipsList.innerHTML = '';
        (data.tips || []).forEach(tip => {
            const li = document.createElement('li');
            li.className = 'mb-2';
            li.innerHTML = '<i class="bi bi-lightbulb text-warning me-2"></i>' + tip;
            tipsList.appendChild(li);
        });
        
        // High score
        document.getElementById('new-high-score-banner').style.display = 
            data.is_new_high_score ? 'block' : 'none';
        
        new bootstrap.Modal(document.getElementById('results-modal')).show();
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    const game = new TimingGame();
    game.init();
});
</script>
{% endblock %}
